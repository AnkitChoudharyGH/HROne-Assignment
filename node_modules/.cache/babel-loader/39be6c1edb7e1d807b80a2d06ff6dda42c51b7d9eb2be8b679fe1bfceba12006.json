{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec'), require('@jridgewell/trace-mapping')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec', '@jridgewell/trace-mapping'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));\n})(this, function (exports, setArray, sourcemapCodec, traceMapping) {\n  'use strict';\n\n  const COLUMN = 0;\n  const SOURCES_INDEX = 1;\n  const SOURCE_LINE = 2;\n  const SOURCE_COLUMN = 3;\n  const NAMES_INDEX = 4;\n  const NO_NAME = -1;\n  /**\n   * Provides the state to generate a sourcemap.\n   */\n  class GenMapping {\n    constructor() {\n      let {\n        file,\n        sourceRoot\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._names = new setArray.SetArray();\n      this._sources = new setArray.SetArray();\n      this._sourcesContent = [];\n      this._mappings = [];\n      this.file = file;\n      this.sourceRoot = sourceRoot;\n      this._ignoreList = new setArray.SetArray();\n    }\n  }\n  /**\n   * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n   * with public access modifiers.\n   */\n  function cast(map) {\n    return map;\n  }\n  function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  }\n  function addMapping(map, mapping) {\n    return addMappingInternal(false, map, mapping);\n  }\n  /**\n   * Same as `addSegment`, but will only add the segment if it generates useful information in the\n   * resulting map. This only works correctly if segments are added **in order**, meaning you should\n   * not add a segment with a lower generated line/column than one that came before.\n   */\n  const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  };\n  /**\n   * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n   * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n   * not add a mapping with a lower generated line/column than one that came before.\n   */\n  const maybeAddMapping = (map, mapping) => {\n    return addMappingInternal(true, map, mapping);\n  };\n  /**\n   * Adds/removes the content of the source file to the source map.\n   */\n  function setSourceContent(map, source, content) {\n    const {\n      _sources: sources,\n      _sourcesContent: sourcesContent\n    } = cast(map);\n    const index = setArray.put(sources, source);\n    sourcesContent[index] = content;\n  }\n  function setIgnore(map, source) {\n    let ignore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const {\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _ignoreList: ignoreList\n    } = cast(map);\n    const index = setArray.put(sources, source);\n    if (index === sourcesContent.length) sourcesContent[index] = null;\n    if (ignore) setArray.put(ignoreList, index);else setArray.remove(ignoreList, index);\n  }\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  function toDecodedMap(map) {\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names,\n      _ignoreList: ignoreList\n    } = cast(map);\n    removeEmptyFinalLines(mappings);\n    return {\n      version: 3,\n      file: map.file || undefined,\n      names: names.array,\n      sourceRoot: map.sourceRoot || undefined,\n      sources: sources.array,\n      sourcesContent,\n      mappings,\n      ignoreList: ignoreList.array\n    };\n  }\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  function toEncodedMap(map) {\n    const decoded = toDecodedMap(map);\n    return Object.assign(Object.assign({}, decoded), {\n      mappings: sourcemapCodec.encode(decoded.mappings)\n    });\n  }\n  /**\n   * Constructs a new GenMapping, using the already present mappings of the input.\n   */\n  function fromMap(input) {\n    const map = new traceMapping.TraceMap(input);\n    const gen = new GenMapping({\n      file: map.file,\n      sourceRoot: map.sourceRoot\n    });\n    putAll(cast(gen)._names, map.names);\n    putAll(cast(gen)._sources, map.sources);\n    cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n    cast(gen)._mappings = traceMapping.decodedMappings(map);\n    if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n    return gen;\n  }\n  /**\n   * Returns an array of high-level mapping objects for every recorded segment, which could then be\n   * passed to the `source-map` library.\n   */\n  function allMappings(map) {\n    const out = [];\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _names: names\n    } = cast(map);\n    for (let i = 0; i < mappings.length; i++) {\n      const line = mappings[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generated = {\n          line: i + 1,\n          column: seg[COLUMN]\n        };\n        let source = undefined;\n        let original = undefined;\n        let name = undefined;\n        if (seg.length !== 1) {\n          source = sources.array[seg[SOURCES_INDEX]];\n          original = {\n            line: seg[SOURCE_LINE] + 1,\n            column: seg[SOURCE_COLUMN]\n          };\n          if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n        }\n        out.push({\n          generated,\n          source,\n          original,\n          name\n        });\n      }\n    }\n    return out;\n  }\n  // This split declaration is only so that terser can elminiate the static initialization block.\n  function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names\n    } = cast(map);\n    const line = getLine(mappings, genLine);\n    const index = getColumnIndex(line, genColumn);\n    if (!source) {\n      if (skipable && skipSourceless(line, index)) return;\n      return insert(line, index, [genColumn]);\n    }\n    const sourcesIndex = setArray.put(sources, source);\n    const namesIndex = name ? setArray.put(names, name) : NO_NAME;\n    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n      return;\n    }\n    return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n  }\n  function getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n      mappings[i] = [];\n    }\n    return mappings[index];\n  }\n  function getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n      const current = line[i];\n      if (genColumn >= current[COLUMN]) break;\n    }\n    return index;\n  }\n  function insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n    array[index] = value;\n  }\n  function removeEmptyFinalLines(mappings) {\n    const {\n      length\n    } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n      if (mappings[i].length > 0) break;\n    }\n    if (len < length) mappings.length = len;\n  }\n  function putAll(setarr, array) {\n    for (let i = 0; i < array.length; i++) setArray.put(setarr, array[i]);\n  }\n  function skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0) return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n  }\n  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0) return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1) return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n  }\n  function addMappingInternal(skipable, map, mapping) {\n    const {\n      generated,\n      source,\n      original,\n      name,\n      content\n    } = mapping;\n    if (!source) {\n      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    }\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n  }\n  exports.GenMapping = GenMapping;\n  exports.addMapping = addMapping;\n  exports.addSegment = addSegment;\n  exports.allMappings = allMappings;\n  exports.fromMap = fromMap;\n  exports.maybeAddMapping = maybeAddMapping;\n  exports.maybeAddSegment = maybeAddSegment;\n  exports.setIgnore = setIgnore;\n  exports.setSourceContent = setSourceContent;\n  exports.toDecodedMap = toDecodedMap;\n  exports.toEncodedMap = toEncodedMap;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","NO_NAME","GenMapping","constructor","file","sourceRoot","arguments","length","undefined","_names","setArray","SetArray","_sources","_sourcesContent","_mappings","_ignoreList","cast","map","addSegment","genLine","genColumn","source","sourceLine","sourceColumn","name","content","addSegmentInternal","addMapping","mapping","addMappingInternal","maybeAddSegment","maybeAddMapping","setSourceContent","sources","sourcesContent","index","put","setIgnore","ignore","ignoreList","remove","toDecodedMap","mappings","names","removeEmptyFinalLines","version","array","toEncodedMap","decoded","Object","assign","sourcemapCodec","encode","fromMap","input","traceMapping","TraceMap","gen","putAll","decodedMappings","allMappings","out","i","line","j","seg","generated","column","original","push","skipable","getLine","getColumnIndex","skipSourceless","insert","sourcesIndex","namesIndex","skipSource","current","value","len","setarr","prev"],"sources":["C:\\Users\\Ankit Choudhary\\Desktop\\learn-react\\top-course-starter\\node_modules\\sucrase\\node_modules\\@jridgewell\\gen-mapping\\src\\sourcemap-segment.ts","C:\\Users\\Ankit Choudhary\\Desktop\\learn-react\\top-course-starter\\node_modules\\sucrase\\node_modules\\@jridgewell\\gen-mapping\\src\\gen-mapping.ts"],"sourcesContent":["type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n","import { SetArray, put, remove } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private declare _names: SetArray<string>;\n  private declare _sources: SetArray<string>;\n  private declare _sourcesContent: (string | null)[];\n  private declare _mappings: SourceMapSegment[][];\n  private declare _ignoreList: SetArray<number>;\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n}\n\ninterface PublicMap {\n  _names: GenMapping['_names'];\n  _sources: GenMapping['_sources'];\n  _sourcesContent: GenMapping['_sourcesContent'];\n  _mappings: GenMapping['_mappings'];\n  _ignoreList: GenMapping['_ignoreList'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: null,\n  sourceLine?: null,\n  sourceColumn?: null,\n  name?: null,\n  content?: null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name?: null,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name: string,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: string | null,\n  sourceLine?: number | null,\n  sourceColumn?: number | null,\n  name?: string | null,\n  content?: string | null,\n): void {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n}\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: null;\n    original?: null;\n    name?: null;\n    content?: null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name?: null;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name: string;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: string | null;\n    original?: Pos | null;\n    name?: string | null;\n    content?: string | null;\n  },\n): void {\n  return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n}\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport const maybeAddSegment: typeof addSegment = (\n  map,\n  genLine,\n  genColumn,\n  source,\n  sourceLine,\n  sourceColumn,\n  name,\n  content,\n) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n};\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport const maybeAddMapping: typeof addMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport function setSourceContent(map: GenMapping, source: string, content: string | null): void {\n  const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\n\nexport function setIgnore(map: GenMapping, source: string, ignore = true) {\n  const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toDecodedMap(map: GenMapping): DecodedSourceMap {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList,\n  } = cast(map);\n  removeEmptyFinalLines(mappings);\n\n  return {\n    version: 3,\n    file: map.file || undefined,\n    names: names.array,\n    sourceRoot: map.sourceRoot || undefined,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    ignoreList: ignoreList.array,\n  };\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toEncodedMap(map: GenMapping): EncodedSourceMap {\n  const decoded = toDecodedMap(map);\n  return {\n    ...decoded,\n    mappings: encode(decoded.mappings as SourceMapSegment[][]),\n  };\n}\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport function fromMap(input: SourceMapInput): GenMapping {\n  const map = new TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n  putAll(cast(gen)._names, map.names);\n  putAll(cast(gen)._sources, map.sources as string[]);\n  cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast(gen)._mappings = decodedMappings(map) as GenMapping['_mappings'];\n  if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n\n  return gen;\n}\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport function allMappings(map: GenMapping): Mapping[] {\n  const out: Mapping[] = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source: string | undefined = undefined;\n      let original: Pos | undefined = undefined;\n      let name: string | undefined = undefined;\n\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n\n      out.push({ generated, source, original, name } as Mapping);\n    }\n  }\n\n  return out;\n}\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n): void {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n  } = cast(map);\n  const line = getLine(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n\n  // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n  // isn't nullish.\n  assert<number>(sourceLine);\n  assert<number>(sourceColumn);\n\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n\n  return insert(\n    line,\n    index,\n    name\n      ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n      : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n  );\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll<T extends string | number>(setarr: SetArray<T>, array: T[]) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source as string,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}