{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  INTERNAL_FEATURES: function () {\n    return INTERNAL_FEATURES;\n  },\n  isValidVariantFormatString: function () {\n    return isValidVariantFormatString;\n  },\n  parseVariant: function () {\n    return parseVariant;\n  },\n  getFileModifiedMap: function () {\n    return getFileModifiedMap;\n  },\n  createContext: function () {\n    return createContext;\n  },\n  getContext: function () {\n    return getContext;\n  }\n});\nconst _fs = /*#__PURE__*/_interop_require_default(require(\"fs\"));\nconst _url = /*#__PURE__*/_interop_require_default(require(\"url\"));\nconst _postcss = /*#__PURE__*/_interop_require_default(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/_interop_require_default(require(\"dlv\"));\nconst _postcssselectorparser = /*#__PURE__*/_interop_require_default(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/_interop_require_default(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/_interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/_interop_require_default(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/_interop_require_default(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/_interop_require_default(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/_interop_require_wildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/_interop_require_wildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/_interop_require_default(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/_interop_require_default(require(\"../util/negateValue\"));\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/_interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidation = require(\"./cacheInvalidation.js\");\nconst _offsets = require(\"./offsets.js\");\nconst _featureFlags = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst INTERNAL_FEATURES = Symbol();\nconst VARIANT_TYPES = {\n  AddVariant: Symbol.for(\"ADD_VARIANT\"),\n  MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n  Base: 1 << 0,\n  Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes(_ref) {\n  let {\n    type = \"any\",\n    ...options\n  } = _ref;\n  let types = [].concat(type);\n  return {\n    ...options,\n    types: types.map(type => {\n      if (Array.isArray(type)) {\n        return {\n          type: type[0],\n          ...type[1]\n        };\n      }\n      return {\n        type,\n        preferOnConflict: false\n      };\n    })\n  };\n}\nfunction parseVariantFormatString(input) {\n  /** @type {string[]} */let parts = [];\n  // When parsing whitespace around special characters are insignificant\n  // However, _inside_ of a variant they could be\n  // Because the selector could look like this\n  // @media { &[data-name=\"foo bar\"] }\n  // This is why we do not skip whitespace\n  let current = \"\";\n  let depth = 0;\n  for (let idx = 0; idx < input.length; idx++) {\n    let char = input[idx];\n    if (char === \"\\\\\") {\n      // Escaped characters are not special\n      current += \"\\\\\" + input[++idx];\n    } else if (char === \"{\") {\n      // Nested rule: start\n      ++depth;\n      parts.push(current.trim());\n      current = \"\";\n    } else if (char === \"}\") {\n      // Nested rule: end\n      if (--depth < 0) {\n        throw new Error(`Your { and } are unbalanced.`);\n      }\n      parts.push(current.trim());\n      current = \"\";\n    } else {\n      // Normal character\n      current += char;\n    }\n  }\n  if (current.length > 0) {\n    parts.push(current.trim());\n  }\n  parts = parts.filter(part => part !== \"\");\n  return parts;\n}\nfunction insertInto(list, value) {\n  let {\n    before = []\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  before = [].concat(before);\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n  let idx = list.length - 1;\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n  list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n    return isNode ? style : (0, _parseObjectStyles.default)(style);\n  });\n}\nfunction getClasses(selector, mutate) {\n  let parser = (0, _postcssselectorparser.default)(selectors => {\n    let allClasses = [];\n    if (mutate) {\n      mutate(selectors);\n    }\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\n/**\n * Ignore everything inside a :not(...). This allows you to write code like\n * `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n * not generated it. But now we will ignore everything inside a `:not`, so\n * that it still gets generated.\n *\n * @param {selectorParser.Root} selectors\n */\nfunction ignoreNot(selectors) {\n  selectors.walkPseudos(pseudo => {\n    if (pseudo.value === \":not\") {\n      pseudo.remove();\n    }\n  });\n}\nfunction extractCandidates(node) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    containsNonOnDemandable: false\n  };\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let classes = [];\n  let selectors = [];\n  if (node.type === \"rule\") {\n    // Handle normal rules\n    selectors.push(...node.selectors);\n  } else if (node.type === \"atrule\") {\n    // Handle at-rules (which contains nested rules)\n    node.walkRules(rule => selectors.push(...rule.selectors));\n  }\n  for (let selector of selectors) {\n    let classCandidates = getClasses(selector, ignoreNot);\n    // At least one of the selectors contains non-\"on-demandable\" candidates.\n    if (classCandidates.length === 0) {\n      state.containsNonOnDemandable = true;\n    }\n    for (let classCandidate of classCandidates) {\n      classes.push(classCandidate);\n    }\n  }\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes];\n  }\n  return classes;\n}\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n    // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(_sharedState.NOT_ON_DEMAND);\n    }\n    // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\nfunction isValidVariantFormatString(format) {\n  return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n  variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n  let fns = parseVariantFormatString(variant).map(str => {\n    if (!str.startsWith(\"@\")) {\n      return _ref2 => {\n        let {\n          format\n        } = _ref2;\n        return format(str);\n      };\n    }\n    let [, name, params] = /@(\\S*)( .+|[({].*)?/g.exec(str);\n    var _params_trim;\n    return _ref3 => {\n      let {\n        wrap\n      } = _ref3;\n      return wrap(_postcss.default.atRule({\n        name,\n        params: (_params_trim = params === null || params === void 0 ? void 0 : params.trim()) !== null && _params_trim !== void 0 ? _params_trim : \"\"\n      }));\n    };\n  }).reverse();\n  return api => {\n    for (let fn of fns) {\n      fn(api);\n    }\n  };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */\nfunction buildPluginApi(tailwindConfig, context, _ref4) {\n  let {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  } = _ref4;\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n  }\n  function prefixIdentifier(identifier, options) {\n    if (identifier === _sharedState.NOT_ON_DEMAND) {\n      return _sharedState.NOT_ON_DEMAND;\n    }\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n    return context.tailwindConfig.prefix + identifier;\n  }\n  function resolveThemeValue(path, defaultValue) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let parts = (0, _toPath.toPath)(path);\n    let value = getConfigValue([\"theme\", ...parts], defaultValue);\n    return (0, _transformThemeValue.default)(parts[0])(value, opts);\n  }\n  let variantIdentifier = 0;\n  let api = {\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n    theme: resolveThemeValue,\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n      return getConfigValue([\"corePlugins\", path], true);\n    },\n    variants: () => {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return [];\n    },\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.create(\"base\");\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: \"base\"\n        }, rule]);\n      }\n    },\n    /**\n    * @param {string} group\n    * @param {Record<string, string | string[]>} declarations\n    */\n    addDefaults(group, declarations) {\n      const groups = {\n        [`@defaults ${group}`]: declarations\n      };\n      for (let [identifier, rule] of withIdentifiers(groups)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"defaults\"),\n          layer: \"defaults\"\n        }, rule]);\n      }\n    },\n    addComponents(components, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"components\"),\n          layer: \"components\",\n          options\n        }, rule]);\n      }\n    },\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.create(\"utilities\"),\n          layer: \"utilities\",\n          options\n        }, rule]);\n      }\n    },\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"utilities\");\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, _ref5) {\n          let {\n            isOnlyPlugin\n          } = _ref5;\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(_ref6 => {\n            let {\n              type\n            } = _ref6;\n            return type === coercedType;\n          })) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"utilities\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    matchComponents: function (components, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false,\n        modifiers: false\n      };\n      options = normalizeOptionTypes({\n        ...defaultOptions,\n        ...options\n      });\n      let offset = offsets.create(\"components\");\n      for (let identifier in components) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = components[identifier];\n        classList.add([prefixedIdentifier, options]);\n        function wrapped(modifier, _ref7) {\n          let {\n            isOnlyPlugin\n          } = _ref7;\n          let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n          if (value === undefined) {\n            return [];\n          }\n          if (!options.types.some(_ref8 => {\n            let {\n              type\n            } = _ref8;\n            return type === coercedType;\n          })) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n          if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n            return [];\n          }\n          let extras = {\n            get modifier() {\n              if (!options.modifiers) {\n                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\"Your plugin must set `modifiers: true` in its options to support modifiers.\"]);\n              }\n              return utilityModifier;\n            }\n          };\n          let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n          let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n        let withOffsets = [{\n          sort: offset,\n          layer: \"components\",\n          options\n        }, wrapped];\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    addVariant(variantName, variantFunctions) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      variantFunctions = [].concat(variantFunctions).map(variantFunction => {\n        if (typeof variantFunction !== \"string\") {\n          // Safelist public API functions\n          return function () {\n            let api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            let {\n              args,\n              modifySelectors,\n              container,\n              separator,\n              wrap,\n              format\n            } = api;\n            let result = variantFunction(Object.assign({\n              modifySelectors,\n              container,\n              separator\n            }, options.type === VARIANT_TYPES.MatchVariant && {\n              args,\n              wrap,\n              format\n            }));\n            if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n              throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n            }\n            if (Array.isArray(result)) {\n              return result.filter(variant => typeof variant === \"string\").map(variant => parseVariant(variant));\n            }\n            // result may be undefined with legacy variants that use APIs like `modifySelectors`\n            // result may also be a postcss node if someone was returning the result from `modifySelectors`\n            return result && typeof result === \"string\" && parseVariant(result)(api);\n          };\n        }\n        if (!isValidVariantFormatString(variantFunction)) {\n          throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n        }\n        return parseVariant(variantFunction);\n      });\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n      context.variantOptions.set(variantName, options);\n    },\n    matchVariant(variant, variantFn, options) {\n      var _options_id;\n      // A unique identifier that \"groups\" these variants together.\n      // This is for internal use only which is why it is not present in the types\n      let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;\n      let isSpecial = variant === \"@\";\n      let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n      var _options_values;\n      for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})) {\n        if (key === \"DEFAULT\") continue;\n        api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, _ref9 => {\n          let {\n            args,\n            container\n          } = _ref9;\n          return variantFn(value, modifiersEnabled ? {\n            modifier: args === null || args === void 0 ? void 0 : args.modifier,\n            container\n          } : {\n            container\n          });\n        }, {\n          ...options,\n          value,\n          id,\n          type: VARIANT_TYPES.MatchVariant,\n          variantInfo: VARIANT_INFO.Base\n        });\n      }\n      var _options_values1;\n      let hasDefault = (\"DEFAULT\" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n      api.addVariant(variant, _ref10 => {\n        let {\n          args,\n          container\n        } = _ref10;\n        if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n          return null;\n        }\n        var\n        // (JetBrains) plugins.\n        _args_value;\n        return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n          modifier: args === null || args === void 0 ? void 0 : args.modifier,\n          container\n        } : {\n          container\n        });\n      }, {\n        ...options,\n        id,\n        type: VARIANT_TYPES.MatchVariant,\n        variantInfo: VARIANT_INFO.Dynamic\n      });\n    }\n  };\n  return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n  return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n  let mtimesToCommit = new Map();\n  for (let file of files) {\n    var _fs_statSync;\n    if (!file) continue;\n    let parsed = _url.default.parse(file);\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n    let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {\n      throwIfNoEntry: false\n    })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;\n    if (!newModified) {\n      continue;\n    }\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n    mtimesToCommit.set(file, newModified);\n  }\n  return [changed, mtimesToCommit];\n}\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if ([\"responsive\", \"variants\"].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === \"atrule\" && [\"responsive\", \"variants\"].includes(node.name)) {\n      node.name = \"layer\";\n      node.params = \"utilities\";\n    }\n  });\n  // Walk @layer rules and treat them like plugins\n  root.walkAtRules(\"layer\", layerRule => {\n    extractVariantAtRules(layerRule);\n    if (layerRule.params === \"base\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref11) {\n          let {\n            addBase\n          } = _ref11;\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"components\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref12) {\n          let {\n            addComponents\n          } = _ref12;\n          addComponents(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    } else if (layerRule.params === \"utilities\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref13) {\n          let {\n            addUtilities\n          } = _ref13;\n          addUtilities(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n  let corePluginList = Object.entries({\n    ..._corePlugins.variantPlugins,\n    ..._corePlugins.corePlugins\n  }).map(_ref14 => {\n    let [name, plugin] = _ref14;\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n    return typeof plugin === \"function\" ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root);\n  // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n  let beforeVariants = [_corePlugins.variantPlugins[\"childVariant\"], _corePlugins.variantPlugins[\"pseudoElementVariants\"], _corePlugins.variantPlugins[\"pseudoClassVariants\"], _corePlugins.variantPlugins[\"hasVariants\"], _corePlugins.variantPlugins[\"ariaVariants\"], _corePlugins.variantPlugins[\"dataVariants\"]];\n  let afterVariants = [_corePlugins.variantPlugins[\"supportsVariants\"], _corePlugins.variantPlugins[\"reducedMotionVariants\"], _corePlugins.variantPlugins[\"prefersContrastVariants\"], _corePlugins.variantPlugins[\"screenVariants\"], _corePlugins.variantPlugins[\"orientationVariants\"], _corePlugins.variantPlugins[\"directionVariants\"], _corePlugins.variantPlugins[\"darkVariants\"], _corePlugins.variantPlugins[\"forcedColorsVariants\"], _corePlugins.variantPlugins[\"printVariant\"]];\n  // This is a compatibility fix for the pre 3.4 dark mode behavior\n  // `class` retains the old behavior, but `selector` keeps the new behavior\n  let isLegacyDarkMode = context.tailwindConfig.darkMode === \"class\" || Array.isArray(context.tailwindConfig.darkMode) && context.tailwindConfig.darkMode[0] === \"class\";\n  if (isLegacyDarkMode) {\n    afterVariants = [_corePlugins.variantPlugins[\"supportsVariants\"], _corePlugins.variantPlugins[\"reducedMotionVariants\"], _corePlugins.variantPlugins[\"prefersContrastVariants\"], _corePlugins.variantPlugins[\"darkVariants\"], _corePlugins.variantPlugins[\"screenVariants\"], _corePlugins.variantPlugins[\"orientationVariants\"], _corePlugins.variantPlugins[\"directionVariants\"], _corePlugins.variantPlugins[\"forcedColorsVariants\"], _corePlugins.variantPlugins[\"printVariant\"]];\n  }\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  context.variantMap = variantMap;\n  let offsets = new _offsets.Offsets();\n  context.offsets = offsets;\n  let classList = new Set();\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  });\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n    }\n  }\n  // Make sure to record bit masks for every variant\n  offsets.recordVariants(variantList, variant => variantMap.get(variant).length);\n  // Build variantMap\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [offsets.forVariant(variantName, idx), variantFunction]));\n  }\n  var _context_tailwindConfig_safelist;\n  let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);\n  if (safelist.length > 0) {\n    let checks = [];\n    for (let value of safelist) {\n      if (typeof value === \"string\") {\n        context.changedContent.push({\n          content: value,\n          extension: \"html\"\n        });\n        continue;\n      }\n      if (value instanceof RegExp) {\n        _log.default.warn(\"root-regex\", [\"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\", \"Update your `safelist` configuration to eliminate this warning.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n        continue;\n      }\n      checks.push(value);\n    }\n    if (checks.length > 0) {\n      let patternMatchingCount = new Map();\n      let prefixLength = context.tailwindConfig.prefix.length;\n      let checkImportantUtils = checks.some(check => check.pattern.source.includes(\"!\"));\n      for (let util of classList) {\n        let utils = Array.isArray(util) ? (() => {\n          let [utilName, options] = util;\n          var _options_values;\n          let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});\n          let classes = values.map(value => (0, _nameClass.formatClass)(utilName, value));\n          if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n            // This is the normal negated version\n            // e.g. `-inset-1` or `-tw-inset-1`\n            classes = [...classes, ...classes.map(cls => \"-\" + cls)];\n            // This is the negated version *after* the prefix\n            // e.g. `tw--inset-1`\n            // The prefix is already attached to util name\n            // So we add the negative after the prefix\n            classes = [...classes, ...classes.map(cls => cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))];\n          }\n          if (options.types.some(_ref15 => {\n            let {\n              type\n            } = _ref15;\n            return type === \"color\";\n          })) {\n            classes = [...classes, ...classes.flatMap(cls => Object.keys(context.tailwindConfig.theme.opacity).map(opacity => `${cls}/${opacity}`))];\n          }\n          if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n            classes = [...classes, ...classes.map(cls => \"!\" + cls)];\n          }\n          return classes;\n        })() : [util];\n        for (let util of utils) {\n          for (let {\n            pattern,\n            variants = []\n          } of checks) {\n            // RegExp with the /g flag are stateful, so let's reset the last\n            // index pointer to reset the state.\n            pattern.lastIndex = 0;\n            if (!patternMatchingCount.has(pattern)) {\n              patternMatchingCount.set(pattern, 0);\n            }\n            if (!pattern.test(util)) continue;\n            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n            context.changedContent.push({\n              content: util,\n              extension: \"html\"\n            });\n            for (let variant of variants) {\n              context.changedContent.push({\n                content: variant + context.tailwindConfig.separator + util,\n                extension: \"html\"\n              });\n            }\n          }\n        }\n      }\n      for (let [regex, count] of patternMatchingCount.entries()) {\n        if (count !== 0) continue;\n        _log.default.warn([`The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`, \"Fix this pattern or remove it from your `safelist` configuration.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n      }\n    }\n  }\n  var _context_tailwindConfig_darkMode, _concat_;\n  let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : \"media\")[1]) !== null && _concat_ !== void 0 ? _concat_ : \"dark\";\n  // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utilities work properly. (Thanks Biology)\n  let parasiteUtilities = [prefix(context, darkClassName), prefix(context, \"group\"), prefix(context, \"peer\")];\n  context.getClassOrder = function getClassOrder(classes) {\n    // Sort classes so they're ordered in a deterministic manner\n    let sorted = [...classes].sort((a, z) => {\n      if (a === z) return 0;\n      if (a < z) return -1;\n      return 1;\n    });\n    // Non-util classes won't be generated, so we default them to null\n    let sortedClassNames = new Map(sorted.map(className => [className, null]));\n    // Sort all classes in order\n    // Non-tailwind classes won't be generated and will be left as `null`\n    let rules = (0, _generateRules.generateRules)(new Set(sorted), context, true);\n    rules = context.offsets.sort(rules);\n    let idx = BigInt(parasiteUtilities.length);\n    for (const [, rule] of rules) {\n      let candidate = rule.raws.tailwind.candidate;\n      var _sortedClassNames_get;\n      // When multiple rules match a candidate\n      // always take the position of the first one\n      sortedClassNames.set(candidate, (_sortedClassNames_get = sortedClassNames.get(candidate)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : idx++);\n    }\n    return classes.map(className => {\n      var _sortedClassNames_get;\n      let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;\n      let parasiteIndex = parasiteUtilities.indexOf(className);\n      if (order === null && parasiteIndex !== -1) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = BigInt(parasiteIndex);\n      }\n      return [className, order];\n    });\n  };\n  // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n  context.getClassList = function getClassList() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let output = [];\n    for (let util of classList) {\n      if (Array.isArray(util)) {\n        var _utilOptions_types;\n        let [utilName, utilOptions] = util;\n        let negativeClasses = [];\n        var _utilOptions_modifiers;\n        let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});\n        if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(_ref16 => {\n          let {\n            type\n          } = _ref16;\n          return type === \"color\";\n        })) {\n          var _context_tailwindConfig_theme_opacity;\n          modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));\n        }\n        let metadata = {\n          modifiers\n        };\n        let includeMetadata = options.includeMetadata && modifiers.length > 0;\n        var _utilOptions_values;\n        for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})) {\n          // Ignore undefined and null values\n          if (value == null) {\n            continue;\n          }\n          let cls = (0, _nameClass.formatClass)(utilName, key);\n          output.push(includeMetadata ? [cls, metadata] : cls);\n          if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n            let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);\n            negativeClasses.push(includeMetadata ? [cls, metadata] : cls);\n          }\n        }\n        output.push(...negativeClasses);\n      } else {\n        output.push(util);\n      }\n    }\n    return output;\n  };\n  // Generate a list of available variants with meta information of the type of variant.\n  context.getVariants = function getVariants() {\n    // We use a unique, random ID for candidate names to avoid conflicts\n    // We can't use characters like `_`, `:`, `@` or `.` because they might\n    // be used as a separator\n    let id = Math.random().toString(36).substring(7).toUpperCase();\n    let result = [];\n    for (let [name, options] of context.variantOptions.entries()) {\n      if (options.variantInfo === VARIANT_INFO.Base) continue;\n      var _options_values;\n      result.push({\n        name,\n        isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n        values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),\n        hasDash: name !== \"@\",\n        selectors() {\n          let {\n            modifier,\n            value\n          } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          let candidate = `TAILWINDPLACEHOLDER${id}`;\n          let rule = _postcss.default.rule({\n            selector: `.${candidate}`\n          });\n          let container = _postcss.default.root({\n            nodes: [rule.clone()]\n          });\n          let before = container.toString();\n          var _context_variantMap_get;\n          let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(_ref17 => {\n            let [_, fn] = _ref17;\n            return fn;\n          });\n          let formatStrings = [];\n          for (let fn of fns) {\n            var _options_values;\n            let localFormatStrings = [];\n            var _options_values_value;\n            let api = {\n              args: {\n                modifier,\n                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value\n              },\n              separator: context.tailwindConfig.separator,\n              modifySelectors(modifierFunction) {\n                // Run the modifierFunction over each rule\n                container.each(rule => {\n                  if (rule.type !== \"rule\") {\n                    return;\n                  }\n                  rule.selectors = rule.selectors.map(selector => {\n                    return modifierFunction({\n                      get className() {\n                        return (0, _generateRules.getClassNameFromSelector)(selector);\n                      },\n                      selector\n                    });\n                  });\n                });\n                return container;\n              },\n              format(str) {\n                localFormatStrings.push(str);\n              },\n              wrap(wrapper) {\n                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n              },\n              container\n            };\n            let ruleWithVariant = fn(api);\n            if (localFormatStrings.length > 0) {\n              formatStrings.push(localFormatStrings);\n            }\n            if (Array.isArray(ruleWithVariant)) {\n              for (let variantFunction of ruleWithVariant) {\n                localFormatStrings = [];\n                variantFunction(api);\n                formatStrings.push(localFormatStrings);\n              }\n            }\n          }\n          // Reverse engineer the result of the `container`\n          let manualFormatStrings = [];\n          let after = container.toString();\n          if (before !== after) {\n            // Figure out all selectors\n            container.walkRules(rule => {\n              let modified = rule.selector;\n              // Rebuild the base selector, this is what plugin authors would do\n              // as well. E.g.: `${variant}${separator}${className}`.\n              // However, plugin authors probably also prepend or append certain\n              // classes, pseudos, ids, ...\n              let rebuiltBase = (0, _postcssselectorparser.default)(selectors => {\n                selectors.walkClasses(classNode => {\n                  classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                });\n              }).processSync(modified);\n              // Now that we know the original selector, the new selector, and\n              // the rebuild part in between, we can replace the part that plugin\n              // authors need to rebuild with `&`, and eventually store it in the\n              // collectedFormats. Similar to what `format('...')` would do.\n              //\n              // E.g.:\n              //                   variant: foo\n              //                  selector: .markdown > p\n              //      modified (by plugin): .foo .foo\\\\:markdown > p\n              //    rebuiltBase (internal): .foo\\\\:markdown > p\n              //                    format: .foo &\n              manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n            });\n            // Figure out all atrules\n            container.walkAtRules(atrule => {\n              manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n            });\n          }\n          var _options_values1;\n          let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n          var _options_INTERNAL_FEATURES;\n          let internalFeatures = (_options_INTERNAL_FEATURES = options[INTERNAL_FEATURES]) !== null && _options_INTERNAL_FEATURES !== void 0 ? _options_INTERNAL_FEATURES : {};\n          let respectPrefix = (() => {\n            if (isArbitraryVariant) return false;\n            if (internalFeatures.respectPrefix === false) return false;\n            return true;\n          })();\n          formatStrings = formatStrings.map(format => format.map(str => ({\n            format: str,\n            respectPrefix\n          })));\n          manualFormatStrings = manualFormatStrings.map(format => ({\n            format,\n            respectPrefix\n          }));\n          let opts = {\n            candidate,\n            context\n          };\n          let result = formatStrings.map(formats => (0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n          if (manualFormatStrings.length > 0) {\n            result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, \"&\"));\n          }\n          return result;\n        }\n      });\n    }\n    return result;\n  };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */\nfunction markInvalidUtilityCandidate(context, candidate) {\n  if (!context.classCache.has(candidate)) {\n    return;\n  }\n  // Mark this as not being a real utility\n  context.notClassCache.add(candidate);\n  // Remove it from any candidate-specific caches\n  context.classCache.delete(candidate);\n  context.applyClassCache.delete(candidate);\n  context.candidateRuleMap.delete(candidate);\n  context.candidateRuleCache.delete(candidate);\n  // Ensure the stylesheet gets rebuilt\n  context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */\nfunction markInvalidUtilityNode(context, node) {\n  let candidate = node.raws.tailwind.candidate;\n  if (!candidate) {\n    return;\n  }\n  for (const entry of context.ruleCache) {\n    if (entry[1].raws.tailwind.candidate === candidate) {\n      context.ruleCache.delete(entry);\n      // context.postCssNodeCache.delete(node)\n    }\n  }\n\n  markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig) {\n  let changedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _postcss.default.root();\n  var _tailwindConfig_blocklist;\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    candidateRuleCache: new Map(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    // Seed the not class cache with the blocklist (which is only strings)\n    notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null,\n    variantOptions: new Map(),\n    markInvalidUtilityCandidate: candidate => markInvalidUtilityCandidate(context, candidate),\n    markInvalidUtilityNode: node => markInvalidUtilityNode(context, node)\n  };\n  let resolvedPlugins = resolvePlugins(context, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n  let existingContext;\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  }\n  let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);\n  // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n  if (existingContext) {\n    let [contextDependenciesChanged, mtimesToCommit] = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n    if (!contextDependenciesChanged && !cssDidChange) {\n      return [existingContext, false, mtimesToCommit];\n    }\n  }\n  // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n        for (let [tailwindConfigHash, context] of configContextMap) {\n          if (context === oldContext) {\n            configContextMap.delete(tailwindConfigHash);\n          }\n        }\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n  _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n  let context = createContext(tailwindConfig, [], root);\n  Object.assign(context, {\n    userConfigPath\n  });\n  let [, mtimesToCommit] = trackModified([...contextDependencies], getFileModifiedMap(context));\n  // ---\n  // Update all context tracking state\n  configContextMap.set(tailwindConfigHash, context);\n  contextMap.set(sourcePath, context);\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set());\n  }\n  contextSourcesMap.get(context).add(sourcePath);\n  return [context, true, mtimesToCommit];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","INTERNAL_FEATURES","isValidVariantFormatString","parseVariant","getFileModifiedMap","createContext","getContext","_fs","_interop_require_default","require","_url","_postcss","_dlv","_postcssselectorparser","_transformThemeValue","_parseObjectStyles","_prefixSelector","_isPlainObject","_escapeClassName","_nameClass","_interop_require_wildcard","_pluginUtils","_corePlugins","_sharedState","_toPath","_log","_negateValue","_isSyntacticallyValidPropertyValue","_generateRules","_cacheInvalidation","_offsets","_featureFlags","_formatVariantSelector","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","VARIANT_TYPES","AddVariant","for","MatchVariant","VARIANT_INFO","Base","Dynamic","prefix","context","selector","tailwindConfig","normalizeOptionTypes","_ref","type","options","types","concat","map","Array","isArray","preferOnConflict","parseVariantFormatString","input","parts","current","depth","idx","length","char","push","trim","Error","filter","part","insertInto","list","before","arguments","undefined","other","iidx","indexOf","Math","min","splice","parseStyles","styles","flatMap","style","isNode","getClasses","mutate","parser","selectors","allClasses","walkClasses","classNode","transformSync","ignoreNot","walkPseudos","pseudo","remove","extractCandidates","node","state","containsNonOnDemandable","classes","walkRules","rule","classCandidates","classCandidate","withIdentifiers","nodeMap","Map","containsNonOnDemandableSelectors","candidates","unshift","NOT_ON_DEMAND","c","format","startsWith","includes","variant","replace","fns","str","_ref2","params","exec","_params_trim","_ref3","wrap","atRule","reverse","api","fn","buildPluginApi","_ref4","variantList","variantMap","offsets","classList","getConfigValue","path","defaultValue","applyConfiguredPrefix","prefixIdentifier","identifier","respectPrefix","resolveThemeValue","opts","toPath","variantIdentifier","postcss","e","config","theme","corePlugins","variants","addBase","base","prefixedIdentifier","offset","create","candidateRuleMap","sort","layer","addDefaults","group","declarations","groups","addComponents","components","defaultOptions","preserveSource","respectImportant","assign","add","addUtilities","utilities","matchUtilities","modifiers","wrapped","modifier","_ref5","isOnlyPlugin","coercedType","utilityModifier","coerceValue","some","_ref6","warn","extras","modifiersEnabled","flagEnabled","ruleSets","Boolean","declaration","withOffsets","matchComponents","_ref7","_ref8","addVariant","variantName","variantFunctions","variantFunction","args","modifySelectors","container","separator","result","variantOptions","matchVariant","variantFn","_options_id","id","isSpecial","_options_values","entries","values","_ref9","variantInfo","_options_values1","hasDefault","_ref10","NONE","_args_value","DEFAULT","fileModifiedMapCache","trackModified","files","fileModifiedMap","changed","mtimesToCommit","file","_fs_statSync","parsed","parse","pathname","hash","href","search","newModified","statSync","decodeURIComponent","throwIfNoEntry","mtimeMs","extractVariantAtRules","walkAtRules","nodes","collectLayerPlugins","root","layerPlugins","each","layerRule","_ref11","_ref12","_ref13","resolvePlugins","corePluginList","variantPlugins","_ref14","plugin","userPlugins","plugins","__isOptionsFunction","handler","beforeVariants","afterVariants","isLegacyDarkMode","darkMode","registerPlugins","Offsets","Set","pluginApi","pluginItem","recordVariants","forVariant","_context_tailwindConfig_safelist","safelist","checks","changedContent","content","extension","RegExp","patternMatchingCount","prefixLength","checkImportantUtils","check","pattern","source","util","utils","utilName","keys","formatClass","supportsNegativeValues","cls","slice","_ref15","opacity","lastIndex","test","regex","count","_context_tailwindConfig_darkMode","_concat_","darkClassName","parasiteUtilities","getClassOrder","sorted","a","z","sortedClassNames","className","rules","generateRules","BigInt","candidate","raws","tailwind","_sortedClassNames_get","order","parasiteIndex","getClassList","output","_utilOptions_types","utilOptions","negativeClasses","_utilOptions_modifiers","_ref16","_context_tailwindConfig_theme_opacity","metadata","includeMetadata","_utilOptions_values","getVariants","random","toString","substring","toUpperCase","isArbitrary","hasDash","clone","_context_variantMap_get","_ref17","_","formatStrings","localFormatStrings","_options_values_value","modifierFunction","getClassNameFromSelector","wrapper","ruleWithVariant","manualFormatStrings","after","modified","rebuiltBase","processSync","atrule","isArbitraryVariant","_options_INTERNAL_FEATURES","internalFeatures","formats","finalizeSelector","formatVariantSelector","markInvalidUtilityCandidate","classCache","notClassCache","delete","applyClassCache","candidateRuleCache","stylesheetCache","markInvalidUtilityNode","entry","ruleCache","_tailwindConfig_blocklist","disposables","blocklist","postCssNodeCache","resolvedPlugins","contextMap","configContextMap","contextSourcesMap","userConfigPath","tailwindConfigHash","contextDependencies","sourcePath","from","isConfigFile","env","DEBUG","console","log","existingContext","cssDidChange","hasContentChanged","contextDependenciesChanged","oldContext","size","disposable"],"sources":["C:/Users/Ankit Choudhary/Desktop/learn-react/top-course-starter/node_modules/tailwindcss/lib/lib/setupContextUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    INTERNAL_FEATURES: function() {\n        return INTERNAL_FEATURES;\n    },\n    isValidVariantFormatString: function() {\n        return isValidVariantFormatString;\n    },\n    parseVariant: function() {\n        return parseVariant;\n    },\n    getFileModifiedMap: function() {\n        return getFileModifiedMap;\n    },\n    createContext: function() {\n        return createContext;\n    },\n    getContext: function() {\n        return getContext;\n    }\n});\nconst _fs = /*#__PURE__*/ _interop_require_default(require(\"fs\"));\nconst _url = /*#__PURE__*/ _interop_require_default(require(\"url\"));\nconst _postcss = /*#__PURE__*/ _interop_require_default(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/ _interop_require_default(require(\"dlv\"));\nconst _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require(\"postcss-selector-parser\"));\nconst _transformThemeValue = /*#__PURE__*/ _interop_require_default(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/ _interop_require_default(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/ _interop_require_default(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/ _interop_require_default(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/ _interop_require_wildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/ _interop_require_wildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/ _interop_require_default(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/ _interop_require_default(require(\"../util/negateValue\"));\nconst _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require(\"../util/isSyntacticallyValidPropertyValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidation = require(\"./cacheInvalidation.js\");\nconst _offsets = require(\"./offsets.js\");\nconst _featureFlags = require(\"../featureFlags.js\");\nconst _formatVariantSelector = require(\"../util/formatVariantSelector\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nconst INTERNAL_FEATURES = Symbol();\nconst VARIANT_TYPES = {\n    AddVariant: Symbol.for(\"ADD_VARIANT\"),\n    MatchVariant: Symbol.for(\"MATCH_VARIANT\")\n};\nconst VARIANT_INFO = {\n    Base: 1 << 0,\n    Dynamic: 1 << 1\n};\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction normalizeOptionTypes({ type =\"any\" , ...options }) {\n    let types = [].concat(type);\n    return {\n        ...options,\n        types: types.map((type)=>{\n            if (Array.isArray(type)) {\n                return {\n                    type: type[0],\n                    ...type[1]\n                };\n            }\n            return {\n                type,\n                preferOnConflict: false\n            };\n        })\n    };\n}\nfunction parseVariantFormatString(input) {\n    /** @type {string[]} */ let parts = [];\n    // When parsing whitespace around special characters are insignificant\n    // However, _inside_ of a variant they could be\n    // Because the selector could look like this\n    // @media { &[data-name=\"foo bar\"] }\n    // This is why we do not skip whitespace\n    let current = \"\";\n    let depth = 0;\n    for(let idx = 0; idx < input.length; idx++){\n        let char = input[idx];\n        if (char === \"\\\\\") {\n            // Escaped characters are not special\n            current += \"\\\\\" + input[++idx];\n        } else if (char === \"{\") {\n            // Nested rule: start\n            ++depth;\n            parts.push(current.trim());\n            current = \"\";\n        } else if (char === \"}\") {\n            // Nested rule: end\n            if (--depth < 0) {\n                throw new Error(`Your { and } are unbalanced.`);\n            }\n            parts.push(current.trim());\n            current = \"\";\n        } else {\n            // Normal character\n            current += char;\n        }\n    }\n    if (current.length > 0) {\n        parts.push(current.trim());\n    }\n    parts = parts.filter((part)=>part !== \"\");\n    return parts;\n}\nfunction insertInto(list, value, { before =[]  } = {}) {\n    before = [].concat(before);\n    if (before.length <= 0) {\n        list.push(value);\n        return;\n    }\n    let idx = list.length - 1;\n    for (let other of before){\n        let iidx = list.indexOf(other);\n        if (iidx === -1) continue;\n        idx = Math.min(idx, iidx);\n    }\n    list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n        return isNode ? style : (0, _parseObjectStyles.default)(style);\n    });\n}\nfunction getClasses(selector, mutate) {\n    let parser = (0, _postcssselectorparser.default)((selectors)=>{\n        let allClasses = [];\n        if (mutate) {\n            mutate(selectors);\n        }\n        selectors.walkClasses((classNode)=>{\n            allClasses.push(classNode.value);\n        });\n        return allClasses;\n    });\n    return parser.transformSync(selector);\n}\n/**\n * Ignore everything inside a :not(...). This allows you to write code like\n * `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n * not generated it. But now we will ignore everything inside a `:not`, so\n * that it still gets generated.\n *\n * @param {selectorParser.Root} selectors\n */ function ignoreNot(selectors) {\n    selectors.walkPseudos((pseudo)=>{\n        if (pseudo.value === \":not\") {\n            pseudo.remove();\n        }\n    });\n}\nfunction extractCandidates(node, state = {\n    containsNonOnDemandable: false\n}, depth = 0) {\n    let classes = [];\n    let selectors = [];\n    if (node.type === \"rule\") {\n        // Handle normal rules\n        selectors.push(...node.selectors);\n    } else if (node.type === \"atrule\") {\n        // Handle at-rules (which contains nested rules)\n        node.walkRules((rule)=>selectors.push(...rule.selectors));\n    }\n    for (let selector of selectors){\n        let classCandidates = getClasses(selector, ignoreNot);\n        // At least one of the selectors contains non-\"on-demandable\" candidates.\n        if (classCandidates.length === 0) {\n            state.containsNonOnDemandable = true;\n        }\n        for (let classCandidate of classCandidates){\n            classes.push(classCandidate);\n        }\n    }\n    if (depth === 0) {\n        return [\n            state.containsNonOnDemandable || classes.length === 0,\n            classes\n        ];\n    }\n    return classes;\n}\nfunction withIdentifiers(styles) {\n    return parseStyles(styles).flatMap((node)=>{\n        let nodeMap = new Map();\n        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n        // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n        if (containsNonOnDemandableSelectors) {\n            candidates.unshift(_sharedState.NOT_ON_DEMAND);\n        }\n        // However, it could be that it also contains \"on-demandable\" candidates.\n        // E.g.: `span, .foo {}`, in that case it should still be possible to use\n        // `@apply foo` for example.\n        return candidates.map((c)=>{\n            if (!nodeMap.has(node)) {\n                nodeMap.set(node, node);\n            }\n            return [\n                c,\n                nodeMap.get(node)\n            ];\n        });\n    });\n}\nfunction isValidVariantFormatString(format) {\n    return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n    variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n    let fns = parseVariantFormatString(variant).map((str)=>{\n        if (!str.startsWith(\"@\")) {\n            return ({ format  })=>format(str);\n        }\n        let [, name, params] = /@(\\S*)( .+|[({].*)?/g.exec(str);\n        var _params_trim;\n        return ({ wrap  })=>{\n            return wrap(_postcss.default.atRule({\n                name,\n                params: (_params_trim = params === null || params === void 0 ? void 0 : params.trim()) !== null && _params_trim !== void 0 ? _params_trim : \"\"\n            }));\n        };\n    }).reverse();\n    return (api)=>{\n        for (let fn of fns){\n            fn(api);\n        }\n    };\n}\n/**\n *\n * @param {any} tailwindConfig\n * @param {any} context\n * @param {object} param2\n * @param {Offsets} param2.offsets\n */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {\n    function getConfigValue(path, defaultValue) {\n        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n    }\n    function applyConfiguredPrefix(selector) {\n        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n    }\n    function prefixIdentifier(identifier, options) {\n        if (identifier === _sharedState.NOT_ON_DEMAND) {\n            return _sharedState.NOT_ON_DEMAND;\n        }\n        if (!options.respectPrefix) {\n            return identifier;\n        }\n        return context.tailwindConfig.prefix + identifier;\n    }\n    function resolveThemeValue(path, defaultValue, opts = {}) {\n        let parts = (0, _toPath.toPath)(path);\n        let value = getConfigValue([\n            \"theme\",\n            ...parts\n        ], defaultValue);\n        return (0, _transformThemeValue.default)(parts[0])(value, opts);\n    }\n    let variantIdentifier = 0;\n    let api = {\n        postcss: _postcss.default,\n        prefix: applyConfiguredPrefix,\n        e: _escapeClassName.default,\n        config: getConfigValue,\n        theme: resolveThemeValue,\n        corePlugins: (path)=>{\n            if (Array.isArray(tailwindConfig.corePlugins)) {\n                return tailwindConfig.corePlugins.includes(path);\n            }\n            return getConfigValue([\n                \"corePlugins\",\n                path\n            ], true);\n        },\n        variants: ()=>{\n            // Preserved for backwards compatibility but not used in v3.0+\n            return [];\n        },\n        addBase (base) {\n            for (let [identifier, rule] of withIdentifiers(base)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                let offset = offsets.create(\"base\");\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offset,\n                        layer: \"base\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */ addDefaults (group, declarations) {\n            const groups = {\n                [`@defaults ${group}`]: declarations\n            };\n            for (let [identifier, rule] of withIdentifiers(groups)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"defaults\"),\n                        layer: \"defaults\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        addComponents (components, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(components)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"components\"),\n                        layer: \"components\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        addUtilities (utilities, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(utilities)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.create(\"utilities\"),\n                        layer: \"utilities\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        matchUtilities: function(utilities, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: true,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"utilities\");\n            for(let identifier in utilities){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = utilities[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"utilities\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        matchComponents: function(components, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: false,\n                modifiers: false\n            };\n            options = normalizeOptionTypes({\n                ...defaultOptions,\n                ...options\n            });\n            let offset = offsets.create(\"components\");\n            for(let identifier in components){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = components[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!options.types.some(({ type  })=>type === coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`\n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {\n                        return [];\n                    }\n                    let extras = {\n                        get modifier () {\n                            if (!options.modifiers) {\n                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [\n                                    \"Your plugin must set `modifiers: true` in its options to support modifiers.\"\n                                ]);\n                            }\n                            return utilityModifier;\n                        }\n                    };\n                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"components\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        addVariant (variantName, variantFunctions, options = {}) {\n            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{\n                if (typeof variantFunction !== \"string\") {\n                    // Safelist public API functions\n                    return (api = {})=>{\n                        let { args , modifySelectors , container , separator , wrap , format  } = api;\n                        let result = variantFunction(Object.assign({\n                            modifySelectors,\n                            container,\n                            separator\n                        }, options.type === VARIANT_TYPES.MatchVariant && {\n                            args,\n                            wrap,\n                            format\n                        }));\n                        if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n                            throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                        }\n                        if (Array.isArray(result)) {\n                            return result.filter((variant)=>typeof variant === \"string\").map((variant)=>parseVariant(variant));\n                        }\n                        // result may be undefined with legacy variants that use APIs like `modifySelectors`\n                        // result may also be a postcss node if someone was returning the result from `modifySelectors`\n                        return result && typeof result === \"string\" && parseVariant(result)(api);\n                    };\n                }\n                if (!isValidVariantFormatString(variantFunction)) {\n                    throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                }\n                return parseVariant(variantFunction);\n            });\n            insertInto(variantList, variantName, options);\n            variantMap.set(variantName, variantFunctions);\n            context.variantOptions.set(variantName, options);\n        },\n        matchVariant (variant, variantFn, options) {\n            var _options_id;\n            // A unique identifier that \"groups\" these variants together.\n            // This is for internal use only which is why it is not present in the types\n            let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;\n            let isSpecial = variant === \"@\";\n            let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, \"generalizedModifiers\");\n            var _options_values;\n            for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})){\n                if (key === \"DEFAULT\") continue;\n                api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args , container  })=>{\n                    return variantFn(value, modifiersEnabled ? {\n                        modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                        container\n                    } : {\n                        container\n                    });\n                }, {\n                    ...options,\n                    value,\n                    id,\n                    type: VARIANT_TYPES.MatchVariant,\n                    variantInfo: VARIANT_INFO.Base\n                });\n            }\n            var _options_values1;\n            let hasDefault = \"DEFAULT\" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {});\n            api.addVariant(variant, ({ args , container  })=>{\n                if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {\n                    return null;\n                }\n                var // (JetBrains) plugins.\n                _args_value;\n                return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === \"string\" ? args : \"\", modifiersEnabled ? {\n                    modifier: args === null || args === void 0 ? void 0 : args.modifier,\n                    container\n                } : {\n                    container\n                });\n            }, {\n                ...options,\n                id,\n                type: VARIANT_TYPES.MatchVariant,\n                variantInfo: VARIANT_INFO.Dynamic\n            });\n        }\n    };\n    return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n    if (!fileModifiedMapCache.has(context)) {\n        fileModifiedMapCache.set(context, new Map());\n    }\n    return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n    let changed = false;\n    let mtimesToCommit = new Map();\n    for (let file of files){\n        var _fs_statSync;\n        if (!file) continue;\n        let parsed = _url.default.parse(file);\n        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n        pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n        let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {\n            throwIfNoEntry: false\n        })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;\n        if (!newModified) {\n            continue;\n        }\n        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n            changed = true;\n        }\n        mtimesToCommit.set(file, newModified);\n    }\n    return [\n        changed,\n        mtimesToCommit\n    ];\n}\nfunction extractVariantAtRules(node) {\n    node.walkAtRules((atRule)=>{\n        if ([\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            extractVariantAtRules(atRule);\n            atRule.before(atRule.nodes);\n            atRule.remove();\n        }\n    });\n}\nfunction collectLayerPlugins(root) {\n    let layerPlugins = [];\n    root.each((node)=>{\n        if (node.type === \"atrule\" && [\n            \"responsive\",\n            \"variants\"\n        ].includes(node.name)) {\n            node.name = \"layer\";\n            node.params = \"utilities\";\n        }\n    });\n    // Walk @layer rules and treat them like plugins\n    root.walkAtRules(\"layer\", (layerRule)=>{\n        extractVariantAtRules(layerRule);\n        if (layerRule.params === \"base\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addBase  }) {\n                    addBase(node, {\n                        respectPrefix: false\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"components\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addComponents  }) {\n                    addComponents(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"utilities\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addUtilities  }) {\n                    addUtilities(node, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        }\n    });\n    return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n    let corePluginList = Object.entries({\n        ..._corePlugins.variantPlugins,\n        ..._corePlugins.corePlugins\n    }).map(([name, plugin])=>{\n        if (!context.tailwindConfig.corePlugins.includes(name)) {\n            return null;\n        }\n        return plugin;\n    }).filter(Boolean);\n    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{\n        if (plugin.__isOptionsFunction) {\n            plugin = plugin();\n        }\n        return typeof plugin === \"function\" ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root);\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [\n        _corePlugins.variantPlugins[\"childVariant\"],\n        _corePlugins.variantPlugins[\"pseudoElementVariants\"],\n        _corePlugins.variantPlugins[\"pseudoClassVariants\"],\n        _corePlugins.variantPlugins[\"hasVariants\"],\n        _corePlugins.variantPlugins[\"ariaVariants\"],\n        _corePlugins.variantPlugins[\"dataVariants\"]\n    ];\n    let afterVariants = [\n        _corePlugins.variantPlugins[\"supportsVariants\"],\n        _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n        _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n        _corePlugins.variantPlugins[\"screenVariants\"],\n        _corePlugins.variantPlugins[\"orientationVariants\"],\n        _corePlugins.variantPlugins[\"directionVariants\"],\n        _corePlugins.variantPlugins[\"darkVariants\"],\n        _corePlugins.variantPlugins[\"forcedColorsVariants\"],\n        _corePlugins.variantPlugins[\"printVariant\"]\n    ];\n    // This is a compatibility fix for the pre 3.4 dark mode behavior\n    // `class` retains the old behavior, but `selector` keeps the new behavior\n    let isLegacyDarkMode = context.tailwindConfig.darkMode === \"class\" || Array.isArray(context.tailwindConfig.darkMode) && context.tailwindConfig.darkMode[0] === \"class\";\n    if (isLegacyDarkMode) {\n        afterVariants = [\n            _corePlugins.variantPlugins[\"supportsVariants\"],\n            _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n            _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n            _corePlugins.variantPlugins[\"darkVariants\"],\n            _corePlugins.variantPlugins[\"screenVariants\"],\n            _corePlugins.variantPlugins[\"orientationVariants\"],\n            _corePlugins.variantPlugins[\"directionVariants\"],\n            _corePlugins.variantPlugins[\"forcedColorsVariants\"],\n            _corePlugins.variantPlugins[\"printVariant\"]\n        ];\n    }\n    return [\n        ...corePluginList,\n        ...beforeVariants,\n        ...userPlugins,\n        ...afterVariants,\n        ...layerPlugins\n    ];\n}\nfunction registerPlugins(plugins, context) {\n    let variantList = [];\n    let variantMap = new Map();\n    context.variantMap = variantMap;\n    let offsets = new _offsets.Offsets();\n    context.offsets = offsets;\n    let classList = new Set();\n    let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n        variantList,\n        variantMap,\n        offsets,\n        classList\n    });\n    for (let plugin of plugins){\n        if (Array.isArray(plugin)) {\n            for (let pluginItem of plugin){\n                pluginItem(pluginApi);\n            }\n        } else {\n            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n        }\n    }\n    // Make sure to record bit masks for every variant\n    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);\n    // Build variantMap\n    for (let [variantName, variantFunctions] of variantMap.entries()){\n        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[\n                offsets.forVariant(variantName, idx),\n                variantFunction\n            ]));\n    }\n    var _context_tailwindConfig_safelist;\n    let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);\n    if (safelist.length > 0) {\n        let checks = [];\n        for (let value of safelist){\n            if (typeof value === \"string\") {\n                context.changedContent.push({\n                    content: value,\n                    extension: \"html\"\n                });\n                continue;\n            }\n            if (value instanceof RegExp) {\n                _log.default.warn(\"root-regex\", [\n                    \"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\n                    \"Update your `safelist` configuration to eliminate this warning.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n                continue;\n            }\n            checks.push(value);\n        }\n        if (checks.length > 0) {\n            let patternMatchingCount = new Map();\n            let prefixLength = context.tailwindConfig.prefix.length;\n            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes(\"!\"));\n            for (let util of classList){\n                let utils = Array.isArray(util) ? (()=>{\n                    let [utilName, options] = util;\n                    var _options_values;\n                    let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});\n                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));\n                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                        // This is the normal negated version\n                        // e.g. `-inset-1` or `-tw-inset-1`\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"-\" + cls)\n                        ];\n                        // This is the negated version *after* the prefix\n                        // e.g. `tw--inset-1`\n                        // The prefix is already attached to util name\n                        // So we add the negative after the prefix\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))\n                        ];\n                    }\n                    if (options.types.some(({ type  })=>type === \"color\")) {\n                        classes = [\n                            ...classes,\n                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))\n                        ];\n                    }\n                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"!\" + cls)\n                        ];\n                    }\n                    return classes;\n                })() : [\n                    util\n                ];\n                for (let util of utils){\n                    for (let { pattern , variants =[]  } of checks){\n                        // RegExp with the /g flag are stateful, so let's reset the last\n                        // index pointer to reset the state.\n                        pattern.lastIndex = 0;\n                        if (!patternMatchingCount.has(pattern)) {\n                            patternMatchingCount.set(pattern, 0);\n                        }\n                        if (!pattern.test(util)) continue;\n                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                        context.changedContent.push({\n                            content: util,\n                            extension: \"html\"\n                        });\n                        for (let variant of variants){\n                            context.changedContent.push({\n                                content: variant + context.tailwindConfig.separator + util,\n                                extension: \"html\"\n                            });\n                        }\n                    }\n                }\n            }\n            for (let [regex, count] of patternMatchingCount.entries()){\n                if (count !== 0) continue;\n                _log.default.warn([\n                    `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n                    \"Fix this pattern or remove it from your `safelist` configuration.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"\n                ]);\n            }\n        }\n    }\n    var _context_tailwindConfig_darkMode, _concat_;\n    let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : \"media\")[1]) !== null && _concat_ !== void 0 ? _concat_ : \"dark\";\n    // A list of utilities that are used by certain Tailwind CSS utilities but\n    // that don't exist on their own. This will result in them \"not existing\" and\n    // sorting could be weird since you still require them in order to make the\n    // host utilities work properly. (Thanks Biology)\n    let parasiteUtilities = [\n        prefix(context, darkClassName),\n        prefix(context, \"group\"),\n        prefix(context, \"peer\")\n    ];\n    context.getClassOrder = function getClassOrder(classes) {\n        // Sort classes so they're ordered in a deterministic manner\n        let sorted = [\n            ...classes\n        ].sort((a, z)=>{\n            if (a === z) return 0;\n            if (a < z) return -1;\n            return 1;\n        });\n        // Non-util classes won't be generated, so we default them to null\n        let sortedClassNames = new Map(sorted.map((className)=>[\n                className,\n                null\n            ]));\n        // Sort all classes in order\n        // Non-tailwind classes won't be generated and will be left as `null`\n        let rules = (0, _generateRules.generateRules)(new Set(sorted), context, true);\n        rules = context.offsets.sort(rules);\n        let idx = BigInt(parasiteUtilities.length);\n        for (const [, rule] of rules){\n            let candidate = rule.raws.tailwind.candidate;\n            var _sortedClassNames_get;\n            // When multiple rules match a candidate\n            // always take the position of the first one\n            sortedClassNames.set(candidate, (_sortedClassNames_get = sortedClassNames.get(candidate)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : idx++);\n        }\n        return classes.map((className)=>{\n            var _sortedClassNames_get;\n            let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;\n            let parasiteIndex = parasiteUtilities.indexOf(className);\n            if (order === null && parasiteIndex !== -1) {\n                // This will make sure that it is at the very beginning of the\n                // `components` layer which technically means 'before any\n                // components'.\n                order = BigInt(parasiteIndex);\n            }\n            return [\n                className,\n                order\n            ];\n        });\n    };\n    // Generate a list of strings for autocompletion purposes, e.g.\n    // ['uppercase', 'lowercase', ...]\n    context.getClassList = function getClassList(options = {}) {\n        let output = [];\n        for (let util of classList){\n            if (Array.isArray(util)) {\n                var _utilOptions_types;\n                let [utilName, utilOptions] = util;\n                let negativeClasses = [];\n                var _utilOptions_modifiers;\n                let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});\n                if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({ type  })=>type === \"color\")) {\n                    var _context_tailwindConfig_theme_opacity;\n                    modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));\n                }\n                let metadata = {\n                    modifiers\n                };\n                let includeMetadata = options.includeMetadata && modifiers.length > 0;\n                var _utilOptions_values;\n                for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})){\n                    // Ignore undefined and null values\n                    if (value == null) {\n                        continue;\n                    }\n                    let cls = (0, _nameClass.formatClass)(utilName, key);\n                    output.push(includeMetadata ? [\n                        cls,\n                        metadata\n                    ] : cls);\n                    if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n                        let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);\n                        negativeClasses.push(includeMetadata ? [\n                            cls,\n                            metadata\n                        ] : cls);\n                    }\n                }\n                output.push(...negativeClasses);\n            } else {\n                output.push(util);\n            }\n        }\n        return output;\n    };\n    // Generate a list of available variants with meta information of the type of variant.\n    context.getVariants = function getVariants() {\n        // We use a unique, random ID for candidate names to avoid conflicts\n        // We can't use characters like `_`, `:`, `@` or `.` because they might\n        // be used as a separator\n        let id = Math.random().toString(36).substring(7).toUpperCase();\n        let result = [];\n        for (let [name, options] of context.variantOptions.entries()){\n            if (options.variantInfo === VARIANT_INFO.Base) continue;\n            var _options_values;\n            result.push({\n                name,\n                isArbitrary: options.type === Symbol.for(\"MATCH_VARIANT\"),\n                values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),\n                hasDash: name !== \"@\",\n                selectors ({ modifier , value  } = {}) {\n                    let candidate = `TAILWINDPLACEHOLDER${id}`;\n                    let rule = _postcss.default.rule({\n                        selector: `.${candidate}`\n                    });\n                    let container = _postcss.default.root({\n                        nodes: [\n                            rule.clone()\n                        ]\n                    });\n                    let before = container.toString();\n                    var _context_variantMap_get;\n                    let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn])=>fn);\n                    let formatStrings = [];\n                    for (let fn of fns){\n                        var _options_values;\n                        let localFormatStrings = [];\n                        var _options_values_value;\n                        let api = {\n                            args: {\n                                modifier,\n                                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value\n                            },\n                            separator: context.tailwindConfig.separator,\n                            modifySelectors (modifierFunction) {\n                                // Run the modifierFunction over each rule\n                                container.each((rule)=>{\n                                    if (rule.type !== \"rule\") {\n                                        return;\n                                    }\n                                    rule.selectors = rule.selectors.map((selector)=>{\n                                        return modifierFunction({\n                                            get className () {\n                                                return (0, _generateRules.getClassNameFromSelector)(selector);\n                                            },\n                                            selector\n                                        });\n                                    });\n                                });\n                                return container;\n                            },\n                            format (str) {\n                                localFormatStrings.push(str);\n                            },\n                            wrap (wrapper) {\n                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);\n                            },\n                            container\n                        };\n                        let ruleWithVariant = fn(api);\n                        if (localFormatStrings.length > 0) {\n                            formatStrings.push(localFormatStrings);\n                        }\n                        if (Array.isArray(ruleWithVariant)) {\n                            for (let variantFunction of ruleWithVariant){\n                                localFormatStrings = [];\n                                variantFunction(api);\n                                formatStrings.push(localFormatStrings);\n                            }\n                        }\n                    }\n                    // Reverse engineer the result of the `container`\n                    let manualFormatStrings = [];\n                    let after = container.toString();\n                    if (before !== after) {\n                        // Figure out all selectors\n                        container.walkRules((rule)=>{\n                            let modified = rule.selector;\n                            // Rebuild the base selector, this is what plugin authors would do\n                            // as well. E.g.: `${variant}${separator}${className}`.\n                            // However, plugin authors probably also prepend or append certain\n                            // classes, pseudos, ids, ...\n                            let rebuiltBase = (0, _postcssselectorparser.default)((selectors)=>{\n                                selectors.walkClasses((classNode)=>{\n                                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;\n                                });\n                            }).processSync(modified);\n                            // Now that we know the original selector, the new selector, and\n                            // the rebuild part in between, we can replace the part that plugin\n                            // authors need to rebuild with `&`, and eventually store it in the\n                            // collectedFormats. Similar to what `format('...')` would do.\n                            //\n                            // E.g.:\n                            //                   variant: foo\n                            //                  selector: .markdown > p\n                            //      modified (by plugin): .foo .foo\\\\:markdown > p\n                            //    rebuiltBase (internal): .foo\\\\:markdown > p\n                            //                    format: .foo &\n                            manualFormatStrings.push(modified.replace(rebuiltBase, \"&\").replace(candidate, \"&\"));\n                        });\n                        // Figure out all atrules\n                        container.walkAtRules((atrule)=>{\n                            manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);\n                        });\n                    }\n                    var _options_values1;\n                    let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));\n                    var _options_INTERNAL_FEATURES;\n                    let internalFeatures = (_options_INTERNAL_FEATURES = options[INTERNAL_FEATURES]) !== null && _options_INTERNAL_FEATURES !== void 0 ? _options_INTERNAL_FEATURES : {};\n                    let respectPrefix = (()=>{\n                        if (isArbitraryVariant) return false;\n                        if (internalFeatures.respectPrefix === false) return false;\n                        return true;\n                    })();\n                    formatStrings = formatStrings.map((format)=>format.map((str)=>({\n                                format: str,\n                                respectPrefix\n                            })));\n                    manualFormatStrings = manualFormatStrings.map((format)=>({\n                            format,\n                            respectPrefix\n                        }));\n                    let opts = {\n                        candidate,\n                        context\n                    };\n                    let result = formatStrings.map((formats)=>(0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, \"&\").replace(\"{ & }\", \"\").trim());\n                    if (manualFormatStrings.length > 0) {\n                        result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, \"&\"));\n                    }\n                    return result;\n                }\n            });\n        }\n        return result;\n    };\n}\n/**\n * Mark as class as retroactively invalid\n *\n *\n * @param {string} candidate\n */ function markInvalidUtilityCandidate(context, candidate) {\n    if (!context.classCache.has(candidate)) {\n        return;\n    }\n    // Mark this as not being a real utility\n    context.notClassCache.add(candidate);\n    // Remove it from any candidate-specific caches\n    context.classCache.delete(candidate);\n    context.applyClassCache.delete(candidate);\n    context.candidateRuleMap.delete(candidate);\n    context.candidateRuleCache.delete(candidate);\n    // Ensure the stylesheet gets rebuilt\n    context.stylesheetCache = null;\n}\n/**\n * Mark as class as retroactively invalid\n *\n * @param {import('postcss').Node} node\n */ function markInvalidUtilityNode(context, node) {\n    let candidate = node.raws.tailwind.candidate;\n    if (!candidate) {\n        return;\n    }\n    for (const entry of context.ruleCache){\n        if (entry[1].raws.tailwind.candidate === candidate) {\n            context.ruleCache.delete(entry);\n        // context.postCssNodeCache.delete(node)\n        }\n    }\n    markInvalidUtilityCandidate(context, candidate);\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n    var _tailwindConfig_blocklist;\n    let context = {\n        disposables: [],\n        ruleCache: new Set(),\n        candidateRuleCache: new Map(),\n        classCache: new Map(),\n        applyClassCache: new Map(),\n        // Seed the not class cache with the blocklist (which is only strings)\n        notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),\n        postCssNodeCache: new Map(),\n        candidateRuleMap: new Map(),\n        tailwindConfig,\n        changedContent: changedContent,\n        variantMap: new Map(),\n        stylesheetCache: null,\n        variantOptions: new Map(),\n        markInvalidUtilityCandidate: (candidate)=>markInvalidUtilityCandidate(context, candidate),\n        markInvalidUtilityNode: (node)=>markInvalidUtilityNode(context, node)\n    };\n    let resolvedPlugins = resolvePlugins(context, root);\n    registerPlugins(resolvedPlugins, context);\n    return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n    let sourcePath = result.opts.from;\n    let isConfigFile = userConfigPath !== null;\n    _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n    let existingContext;\n    if (isConfigFile && contextMap.has(sourcePath)) {\n        existingContext = contextMap.get(sourcePath);\n    } else if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        existingContext = context;\n    }\n    let cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root);\n    // If there's already a context in the cache and we don't need to\n    // reset the context, return the cached context.\n    if (existingContext) {\n        let [contextDependenciesChanged, mtimesToCommit] = trackModified([\n            ...contextDependencies\n        ], getFileModifiedMap(existingContext));\n        if (!contextDependenciesChanged && !cssDidChange) {\n            return [\n                existingContext,\n                false,\n                mtimesToCommit\n            ];\n        }\n    }\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n        let oldContext = contextMap.get(sourcePath);\n        if (contextSourcesMap.has(oldContext)) {\n            contextSourcesMap.get(oldContext).delete(sourcePath);\n            if (contextSourcesMap.get(oldContext).size === 0) {\n                contextSourcesMap.delete(oldContext);\n                for (let [tailwindConfigHash, context] of configContextMap){\n                    if (context === oldContext) {\n                        configContextMap.delete(tailwindConfigHash);\n                    }\n                }\n                for (let disposable of oldContext.disposables.splice(0)){\n                    disposable(oldContext);\n                }\n            }\n        }\n    }\n    _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n    let context = createContext(tailwindConfig, [], root);\n    Object.assign(context, {\n        userConfigPath\n    });\n    let [, mtimesToCommit] = trackModified([\n        ...contextDependencies\n    ], getFileModifiedMap(context));\n    // ---\n    // Update all context tracking state\n    configContextMap.set(tailwindConfigHash, context);\n    contextMap.set(sourcePath, context);\n    if (!contextSourcesMap.has(context)) {\n        contextSourcesMap.set(context, new Set());\n    }\n    contextSourcesMap.get(context).add(sourcePath);\n    return [\n        context,\n        true,\n        mtimesToCommit\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}