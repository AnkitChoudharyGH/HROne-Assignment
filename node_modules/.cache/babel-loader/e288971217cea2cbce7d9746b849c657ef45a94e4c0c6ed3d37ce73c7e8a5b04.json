{"ast":null,"code":"/**\n * @param {import('postcss').Container[]} nodes\n * @param {any} source\n * @param {any} raws\n * @returns {import('postcss').Container[]}\n */\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return cloneNodes;\n  }\n});\nfunction cloneNodes(nodes) {\n  let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let raws = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  return nodes.map(node => {\n    let cloned = node.clone();\n    if (raws !== undefined) {\n      cloned.raws.tailwind = {\n        ...cloned.raws.tailwind,\n        ...raws\n      };\n    }\n    if (source !== undefined) {\n      traverse(cloned, node => {\n        var _node_raws_tailwind;\n        // Do not traverse nodes that have opted\n        // to preserve their original source\n        let shouldPreserveSource = ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.preserveSource) === true && node.source;\n        if (shouldPreserveSource) {\n          return false;\n        }\n        // Otherwise we can safely replace the source\n        // And continue traversing\n        node.source = source;\n      });\n    }\n    return cloned;\n  });\n}\n/**\n * Traverse a tree of nodes and don't traverse children if the callback\n * returns false. Ideally we'd use Container#walk instead of this\n * function but it stops traversing siblings too.\n *\n * @param {import('postcss').Container} node\n * @param {(node: import('postcss').Container) => boolean} onNode\n */\nfunction traverse(node, onNode) {\n  if (onNode(node) !== false) {\n    var _node_each;\n    (_node_each = node.each) === null || _node_each === void 0 ? void 0 : _node_each.call(node, child => traverse(child, onNode));\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","cloneNodes","nodes","source","arguments","length","undefined","raws","map","node","cloned","clone","tailwind","traverse","_node_raws_tailwind","shouldPreserveSource","preserveSource","onNode","_node_each","each","call","child"],"sources":["C:/Users/Ankit Choudhary/Desktop/learn-react/top-course-starter/node_modules/tailwindcss/lib/util/cloneNodes.js"],"sourcesContent":["/**\n * @param {import('postcss').Container[]} nodes\n * @param {any} source\n * @param {any} raws\n * @returns {import('postcss').Container[]}\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return cloneNodes;\n    }\n});\nfunction cloneNodes(nodes, source = undefined, raws = undefined) {\n    return nodes.map((node)=>{\n        let cloned = node.clone();\n        if (raws !== undefined) {\n            cloned.raws.tailwind = {\n                ...cloned.raws.tailwind,\n                ...raws\n            };\n        }\n        if (source !== undefined) {\n            traverse(cloned, (node)=>{\n                var _node_raws_tailwind;\n                // Do not traverse nodes that have opted\n                // to preserve their original source\n                let shouldPreserveSource = ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.preserveSource) === true && node.source;\n                if (shouldPreserveSource) {\n                    return false;\n                }\n                // Otherwise we can safely replace the source\n                // And continue traversing\n                node.source = source;\n            });\n        }\n        return cloned;\n    });\n}\n/**\n * Traverse a tree of nodes and don't traverse children if the callback\n * returns false. Ideally we'd use Container#walk instead of this\n * function but it stops traversing siblings too.\n *\n * @param {import('postcss').Container} node\n * @param {(node: import('postcss').Container) => boolean} onNode\n */ function traverse(node, onNode) {\n    if (onNode(node) !== false) {\n        var _node_each;\n        (_node_each = node.each) === null || _node_each === void 0 ? void 0 : _node_each.call(node, (child)=>traverse(child, onNode));\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,GAAI,YAAY;;AAChBA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,SAAS,EAAE;EACtCE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,OAAOC,UAAU;EACrB;AACJ,CAAC,CAAC;AACF,SAASA,UAAUA,CAACC,KAAK,EAAwC;EAAA,IAAtCC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGE,SAAS;EAAA,IAAEC,IAAI,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGE,SAAS;EAC3D,OAAOJ,KAAK,CAACM,GAAG,CAAEC,IAAI,IAAG;IACrB,IAAIC,MAAM,GAAGD,IAAI,CAACE,KAAK,EAAE;IACzB,IAAIJ,IAAI,KAAKD,SAAS,EAAE;MACpBI,MAAM,CAACH,IAAI,CAACK,QAAQ,GAAG;QACnB,GAAGF,MAAM,CAACH,IAAI,CAACK,QAAQ;QACvB,GAAGL;MACP,CAAC;IACL;IACA,IAAIJ,MAAM,KAAKG,SAAS,EAAE;MACtBO,QAAQ,CAACH,MAAM,EAAGD,IAAI,IAAG;QACrB,IAAIK,mBAAmB;QACvB;QACA;QACA,IAAIC,oBAAoB,GAAG,CAAC,CAACD,mBAAmB,GAAGL,IAAI,CAACF,IAAI,CAACK,QAAQ,MAAM,IAAI,IAAIE,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAACE,cAAc,MAAM,IAAI,IAAIP,IAAI,CAACN,MAAM;QACxL,IAAIY,oBAAoB,EAAE;UACtB,OAAO,KAAK;QAChB;QACA;QACA;QACAN,IAAI,CAACN,MAAM,GAAGA,MAAM;MACxB,CAAC,CAAC;IACN;IACA,OAAOO,MAAM;EACjB,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAASG,QAAQA,CAACJ,IAAI,EAAEQ,MAAM,EAAE;EAChC,IAAIA,MAAM,CAACR,IAAI,CAAC,KAAK,KAAK,EAAE;IACxB,IAAIS,UAAU;IACd,CAACA,UAAU,GAAGT,IAAI,CAACU,IAAI,MAAM,IAAI,IAAID,UAAU,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,UAAU,CAACE,IAAI,CAACX,IAAI,EAAGY,KAAK,IAAGR,QAAQ,CAACQ,KAAK,EAAEJ,MAAM,CAAC,CAAC;EACjI;AACJ"},"metadata":{},"sourceType":"script","externalDependencies":[]}