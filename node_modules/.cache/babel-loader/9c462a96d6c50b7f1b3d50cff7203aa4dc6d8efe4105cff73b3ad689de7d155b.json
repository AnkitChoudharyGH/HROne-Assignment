{"ast":null,"code":"// @ts-check\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Offsets\", {\n  enumerable: true,\n  get: function () {\n    return Offsets;\n  }\n});\nconst _bigSign = /*#__PURE__*/_interop_require_default(require(\"../util/bigSign\"));\nconst _remapbitfield = require(\"./remap-bitfield.js\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass Offsets {\n  constructor() {\n    /**\n    * Offsets for the next rule in a given layer\n    *\n    * @type {Record<Layer, bigint>}\n    */\n    this.offsets = {\n      defaults: 0n,\n      base: 0n,\n      components: 0n,\n      utilities: 0n,\n      variants: 0n,\n      user: 0n\n    };\n    /**\n    * Positions for a given layer\n    *\n    * @type {Record<Layer, bigint>}\n    */\n    this.layerPositions = {\n      defaults: 0n,\n      base: 1n,\n      components: 2n,\n      utilities: 3n,\n      // There isn't technically a \"user\" layer, but we need to give it a position\n      // Because it's used for ordering user-css from @apply\n      user: 4n,\n      variants: 5n\n    };\n    /**\n    * The total number of functions currently registered across all variants (including arbitrary variants)\n    *\n    * @type {bigint}\n    */\n    this.reservedVariantBits = 0n;\n    /**\n    * Positions for a given variant\n    *\n    * @type {Map<string, bigint>}\n    */\n    this.variantOffsets = new Map();\n  }\n  /**\n  * @param {Layer} layer\n  * @returns {RuleOffset}\n  */\n  create(layer) {\n    return {\n      layer,\n      parentLayer: layer,\n      arbitrary: 0n,\n      variants: 0n,\n      parallelIndex: 0n,\n      index: this.offsets[layer]++,\n      propertyOffset: 0n,\n      property: \"\",\n      options: []\n    };\n  }\n  /**\n  * @param {string} name\n  * @returns {RuleOffset}\n  */\n  arbitraryProperty(name) {\n    return {\n      ...this.create(\"utilities\"),\n      arbitrary: 1n,\n      property: name\n    };\n  }\n  /**\n  * Get the offset for a variant\n  *\n  * @param {string} variant\n  * @param {number} index\n  * @returns {RuleOffset}\n  */\n  forVariant(variant) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let offset = this.variantOffsets.get(variant);\n    if (offset === undefined) {\n      throw new Error(`Cannot find offset for unknown variant ${variant}`);\n    }\n    return {\n      ...this.create(\"variants\"),\n      variants: offset << BigInt(index)\n    };\n  }\n  /**\n  * @param {RuleOffset} rule\n  * @param {RuleOffset} variant\n  * @param {VariantOption} options\n  * @returns {RuleOffset}\n  */\n  applyVariantOffset(rule, variant, options) {\n    options.variant = variant.variants;\n    return {\n      ...rule,\n      layer: \"variants\",\n      parentLayer: rule.layer === \"variants\" ? rule.parentLayer : rule.layer,\n      variants: rule.variants | variant.variants,\n      options: options.sort ? [].concat(options, rule.options) : rule.options,\n      // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.\n      // We'll take the max of all the parallel indexes for now.\n      // @ts-ignore\n      parallelIndex: max([rule.parallelIndex, variant.parallelIndex])\n    };\n  }\n  /**\n  * @param {RuleOffset} offset\n  * @param {number} parallelIndex\n  * @returns {RuleOffset}\n  */\n  applyParallelOffset(offset, parallelIndex) {\n    return {\n      ...offset,\n      parallelIndex: BigInt(parallelIndex)\n    };\n  }\n  /**\n  * Each variant gets 1 bit per function / rule registered.\n  * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.\n  * Additionally, every unique group of variants is grouped together in the stylesheet.\n  *\n  * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.\n  *\n  * @param {string[]} variants\n  * @param {(name: string) => number} getLength\n  */\n  recordVariants(variants, getLength) {\n    for (let variant of variants) {\n      this.recordVariant(variant, getLength(variant));\n    }\n  }\n  /**\n  * The same as `recordVariants` but for a single arbitrary variant at runtime.\n  * @param {string} variant\n  * @param {number} fnCount\n  *\n  * @returns {RuleOffset} The highest offset for this variant\n  */\n  recordVariant(variant) {\n    let fnCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.variantOffsets.set(variant, 1n << this.reservedVariantBits);\n    // Ensure space is reserved for each \"function\" in the parallel variant\n    // by offsetting the next variant by the number of parallel variants\n    // in the one we just added.\n    // Single functions that return parallel variants are NOT handled separately here\n    // They're offset by 1 (or the number of functions) as usual\n    // And each rule returned is tracked separately since the functions are evaluated lazily.\n    // @see `RuleOffset.parallelIndex`\n    this.reservedVariantBits += BigInt(fnCount);\n    return {\n      ...this.create(\"variants\"),\n      variants: this.variantOffsets.get(variant)\n    };\n  }\n  /**\n  * @param {RuleOffset} a\n  * @param {RuleOffset} b\n  * @returns {bigint}\n  */\n  compare(a, b) {\n    // Sort layers together\n    if (a.layer !== b.layer) {\n      return this.layerPositions[a.layer] - this.layerPositions[b.layer];\n    }\n    // When sorting the `variants` layer, we need to sort based on the parent layer as well within\n    // this variants layer.\n    if (a.parentLayer !== b.parentLayer) {\n      return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];\n    }\n    // Sort based on the sorting function\n    for (let aOptions of a.options) {\n      for (let bOptions of b.options) {\n        if (aOptions.id !== bOptions.id) continue;\n        if (!aOptions.sort || !bOptions.sort) continue;\n        var _max;\n        let maxFnVariant = (_max = max([aOptions.variant, bOptions.variant])) !== null && _max !== void 0 ? _max : 0n;\n        // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit\n        let mask = ~(maxFnVariant | maxFnVariant - 1n);\n        let aVariantsAfterFn = a.variants & mask;\n        let bVariantsAfterFn = b.variants & mask;\n        // If the variants the same, we _can_ sort them\n        if (aVariantsAfterFn !== bVariantsAfterFn) {\n          continue;\n        }\n        let result = aOptions.sort({\n          value: aOptions.value,\n          modifier: aOptions.modifier\n        }, {\n          value: bOptions.value,\n          modifier: bOptions.modifier\n        });\n        if (result !== 0) return result;\n      }\n    }\n    // Sort variants in the order they were registered\n    if (a.variants !== b.variants) {\n      return a.variants - b.variants;\n    }\n    // Make sure each rule returned by a parallel variant is sorted in ascending order\n    if (a.parallelIndex !== b.parallelIndex) {\n      return a.parallelIndex - b.parallelIndex;\n    }\n    // Always sort arbitrary properties after other utilities\n    if (a.arbitrary !== b.arbitrary) {\n      return a.arbitrary - b.arbitrary;\n    }\n    // Always sort arbitrary properties alphabetically\n    if (a.propertyOffset !== b.propertyOffset) {\n      return a.propertyOffset - b.propertyOffset;\n    }\n    // Sort utilities, components, etc… in the order they were registered\n    return a.index - b.index;\n  }\n  /**\n  * Arbitrary variants are recorded in the order they're encountered.\n  * This means that the order is not stable between environments and sets of content files.\n  *\n  * In order to make the order stable, we need to remap the arbitrary variant offsets to\n  * be in alphabetical order starting from the offset of the first arbitrary variant.\n  */\n  recalculateVariantOffsets() {\n    // Sort the variants by their name\n    let variants = Array.from(this.variantOffsets.entries()).filter(_ref => {\n      let [v] = _ref;\n      return v.startsWith(\"[\");\n    }).sort((_ref2, _ref3) => {\n      let [a] = _ref2;\n      let [z] = _ref3;\n      return fastCompare(a, z);\n    });\n    // Sort the list of offsets\n    // This is not necessarily a discrete range of numbers which is why\n    // we're using sort instead of creating a range from min/max\n    let newOffsets = variants.map(_ref4 => {\n      let [, offset] = _ref4;\n      return offset;\n    }).sort((a, z) => (0, _bigSign.default)(a - z));\n    // Create a map from the old offsets to the new offsets in the new sort order\n    /** @type {[bigint, bigint][]} */\n    let mapping = variants.map((_ref5, i) => {\n      let [, oldOffset] = _ref5;\n      return [oldOffset, newOffsets[i]];\n    });\n    // Remove any variants that will not move letting us skip\n    // remapping if everything happens to be in order\n    return mapping.filter(_ref6 => {\n      let [a, z] = _ref6;\n      return a !== z;\n    });\n  }\n  /**\n  * @template T\n  * @param {[RuleOffset, T][]} list\n  * @returns {[RuleOffset, T][]}\n  */\n  remapArbitraryVariantOffsets(list) {\n    let mapping = this.recalculateVariantOffsets();\n    // No arbitrary variants? Nothing to do.\n    // Everyhing already in order? Nothing to do.\n    if (mapping.length === 0) {\n      return list;\n    }\n    // Remap every variant offset in the list\n    return list.map(item => {\n      let [offset, rule] = item;\n      offset = {\n        ...offset,\n        variants: (0, _remapbitfield.remapBitfield)(offset.variants, mapping)\n      };\n      return [offset, rule];\n    });\n  }\n  /**\n  * @template T\n  * @param {[RuleOffset, T][]} list\n  * @returns {[RuleOffset, T][]}\n  */\n  sortArbitraryProperties(list) {\n    // Collect all known arbitrary properties\n    let known = new Set();\n    for (let [offset] of list) {\n      if (offset.arbitrary === 1n) {\n        known.add(offset.property);\n      }\n    }\n    // No arbitrary properties? Nothing to do.\n    if (known.size === 0) {\n      return list;\n    }\n    // Sort the properties alphabetically\n    let properties = Array.from(known).sort();\n    // Create a map from the property name to its offset\n    let offsets = new Map();\n    let offset = 1n;\n    for (let property of properties) {\n      offsets.set(property, offset++);\n    }\n    // Apply the sorted offsets to the list\n    return list.map(item => {\n      let [offset, rule] = item;\n      var _offsets_get;\n      offset = {\n        ...offset,\n        propertyOffset: (_offsets_get = offsets.get(offset.property)) !== null && _offsets_get !== void 0 ? _offsets_get : 0n\n      };\n      return [offset, rule];\n    });\n  }\n  /**\n  * @template T\n  * @param {[RuleOffset, T][]} list\n  * @returns {[RuleOffset, T][]}\n  */\n  sort(list) {\n    // Sort arbitrary variants so they're in alphabetical order\n    list = this.remapArbitraryVariantOffsets(list);\n    // Sort arbitrary properties so they're in alphabetical order\n    list = this.sortArbitraryProperties(list);\n    return list.sort((_ref7, _ref8) => {\n      let [a] = _ref7;\n      let [b] = _ref8;\n      return (0, _bigSign.default)(this.compare(a, b));\n    });\n  }\n}\n/**\n *\n * @param {bigint[]} nums\n * @returns {bigint|null}\n */\nfunction max(nums) {\n  let max = null;\n  for (const num of nums) {\n    max = max !== null && max !== void 0 ? max : num;\n    max = max > num ? max : num;\n  }\n  return max;\n}\n/**\n * A fast ASCII order string comparison function.\n *\n * Using `.sort()` without a custom compare function is faster\n * But you can only use that if you're sorting an array of\n * only strings. If you're sorting strings inside objects\n * or arrays, you need must use a custom compare function.\n *\n * @param {string} a\n * @param {string} b\n */\nfunction fastCompare(a, b) {\n  let aLen = a.length;\n  let bLen = b.length;\n  let minLen = aLen < bLen ? aLen : bLen;\n  for (let i = 0; i < minLen; i++) {\n    let cmp = a.charCodeAt(i) - b.charCodeAt(i);\n    if (cmp !== 0) return cmp;\n  }\n  return aLen - bLen;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","Offsets","_bigSign","_interop_require_default","require","_remapbitfield","obj","__esModule","default","constructor","offsets","defaults","base","components","utilities","variants","user","layerPositions","reservedVariantBits","variantOffsets","Map","create","layer","parentLayer","arbitrary","parallelIndex","index","propertyOffset","property","options","arbitraryProperty","name","forVariant","variant","arguments","length","undefined","offset","Error","BigInt","applyVariantOffset","rule","sort","concat","max","applyParallelOffset","recordVariants","getLength","recordVariant","fnCount","set","compare","a","b","aOptions","bOptions","id","_max","maxFnVariant","mask","aVariantsAfterFn","bVariantsAfterFn","result","modifier","recalculateVariantOffsets","Array","from","entries","filter","_ref","v","startsWith","_ref2","_ref3","z","fastCompare","newOffsets","map","_ref4","mapping","_ref5","i","oldOffset","_ref6","remapArbitraryVariantOffsets","list","item","remapBitfield","sortArbitraryProperties","known","Set","add","size","properties","_offsets_get","_ref7","_ref8","nums","num","aLen","bLen","minLen","cmp","charCodeAt"],"sources":["C:/Users/Ankit Choudhary/Desktop/learn-react/top-course-starter/node_modules/tailwindcss/lib/lib/offsets.js"],"sourcesContent":["// @ts-check\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"Offsets\", {\n    enumerable: true,\n    get: function() {\n        return Offsets;\n    }\n});\nconst _bigSign = /*#__PURE__*/ _interop_require_default(require(\"../util/bigSign\"));\nconst _remapbitfield = require(\"./remap-bitfield.js\");\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nclass Offsets {\n    constructor(){\n        /**\n     * Offsets for the next rule in a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.offsets = {\n            defaults: 0n,\n            base: 0n,\n            components: 0n,\n            utilities: 0n,\n            variants: 0n,\n            user: 0n\n        };\n        /**\n     * Positions for a given layer\n     *\n     * @type {Record<Layer, bigint>}\n     */ this.layerPositions = {\n            defaults: 0n,\n            base: 1n,\n            components: 2n,\n            utilities: 3n,\n            // There isn't technically a \"user\" layer, but we need to give it a position\n            // Because it's used for ordering user-css from @apply\n            user: 4n,\n            variants: 5n\n        };\n        /**\n     * The total number of functions currently registered across all variants (including arbitrary variants)\n     *\n     * @type {bigint}\n     */ this.reservedVariantBits = 0n;\n        /**\n     * Positions for a given variant\n     *\n     * @type {Map<string, bigint>}\n     */ this.variantOffsets = new Map();\n    }\n    /**\n   * @param {Layer} layer\n   * @returns {RuleOffset}\n   */ create(layer) {\n        return {\n            layer,\n            parentLayer: layer,\n            arbitrary: 0n,\n            variants: 0n,\n            parallelIndex: 0n,\n            index: this.offsets[layer]++,\n            propertyOffset: 0n,\n            property: \"\",\n            options: []\n        };\n    }\n    /**\n   * @param {string} name\n   * @returns {RuleOffset}\n   */ arbitraryProperty(name) {\n        return {\n            ...this.create(\"utilities\"),\n            arbitrary: 1n,\n            property: name\n        };\n    }\n    /**\n   * Get the offset for a variant\n   *\n   * @param {string} variant\n   * @param {number} index\n   * @returns {RuleOffset}\n   */ forVariant(variant, index = 0) {\n        let offset = this.variantOffsets.get(variant);\n        if (offset === undefined) {\n            throw new Error(`Cannot find offset for unknown variant ${variant}`);\n        }\n        return {\n            ...this.create(\"variants\"),\n            variants: offset << BigInt(index)\n        };\n    }\n    /**\n   * @param {RuleOffset} rule\n   * @param {RuleOffset} variant\n   * @param {VariantOption} options\n   * @returns {RuleOffset}\n   */ applyVariantOffset(rule, variant, options) {\n        options.variant = variant.variants;\n        return {\n            ...rule,\n            layer: \"variants\",\n            parentLayer: rule.layer === \"variants\" ? rule.parentLayer : rule.layer,\n            variants: rule.variants | variant.variants,\n            options: options.sort ? [].concat(options, rule.options) : rule.options,\n            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.\n            // We'll take the max of all the parallel indexes for now.\n            // @ts-ignore\n            parallelIndex: max([\n                rule.parallelIndex,\n                variant.parallelIndex\n            ])\n        };\n    }\n    /**\n   * @param {RuleOffset} offset\n   * @param {number} parallelIndex\n   * @returns {RuleOffset}\n   */ applyParallelOffset(offset, parallelIndex) {\n        return {\n            ...offset,\n            parallelIndex: BigInt(parallelIndex)\n        };\n    }\n    /**\n   * Each variant gets 1 bit per function / rule registered.\n   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.\n   * Additionally, every unique group of variants is grouped together in the stylesheet.\n   *\n   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.\n   *\n   * @param {string[]} variants\n   * @param {(name: string) => number} getLength\n   */ recordVariants(variants, getLength) {\n        for (let variant of variants){\n            this.recordVariant(variant, getLength(variant));\n        }\n    }\n    /**\n   * The same as `recordVariants` but for a single arbitrary variant at runtime.\n   * @param {string} variant\n   * @param {number} fnCount\n   *\n   * @returns {RuleOffset} The highest offset for this variant\n   */ recordVariant(variant, fnCount = 1) {\n        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);\n        // Ensure space is reserved for each \"function\" in the parallel variant\n        // by offsetting the next variant by the number of parallel variants\n        // in the one we just added.\n        // Single functions that return parallel variants are NOT handled separately here\n        // They're offset by 1 (or the number of functions) as usual\n        // And each rule returned is tracked separately since the functions are evaluated lazily.\n        // @see `RuleOffset.parallelIndex`\n        this.reservedVariantBits += BigInt(fnCount);\n        return {\n            ...this.create(\"variants\"),\n            variants: this.variantOffsets.get(variant)\n        };\n    }\n    /**\n   * @param {RuleOffset} a\n   * @param {RuleOffset} b\n   * @returns {bigint}\n   */ compare(a, b) {\n        // Sort layers together\n        if (a.layer !== b.layer) {\n            return this.layerPositions[a.layer] - this.layerPositions[b.layer];\n        }\n        // When sorting the `variants` layer, we need to sort based on the parent layer as well within\n        // this variants layer.\n        if (a.parentLayer !== b.parentLayer) {\n            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];\n        }\n        // Sort based on the sorting function\n        for (let aOptions of a.options){\n            for (let bOptions of b.options){\n                if (aOptions.id !== bOptions.id) continue;\n                if (!aOptions.sort || !bOptions.sort) continue;\n                var _max;\n                let maxFnVariant = (_max = max([\n                    aOptions.variant,\n                    bOptions.variant\n                ])) !== null && _max !== void 0 ? _max : 0n;\n                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit\n                let mask = ~(maxFnVariant | maxFnVariant - 1n);\n                let aVariantsAfterFn = a.variants & mask;\n                let bVariantsAfterFn = b.variants & mask;\n                // If the variants the same, we _can_ sort them\n                if (aVariantsAfterFn !== bVariantsAfterFn) {\n                    continue;\n                }\n                let result = aOptions.sort({\n                    value: aOptions.value,\n                    modifier: aOptions.modifier\n                }, {\n                    value: bOptions.value,\n                    modifier: bOptions.modifier\n                });\n                if (result !== 0) return result;\n            }\n        }\n        // Sort variants in the order they were registered\n        if (a.variants !== b.variants) {\n            return a.variants - b.variants;\n        }\n        // Make sure each rule returned by a parallel variant is sorted in ascending order\n        if (a.parallelIndex !== b.parallelIndex) {\n            return a.parallelIndex - b.parallelIndex;\n        }\n        // Always sort arbitrary properties after other utilities\n        if (a.arbitrary !== b.arbitrary) {\n            return a.arbitrary - b.arbitrary;\n        }\n        // Always sort arbitrary properties alphabetically\n        if (a.propertyOffset !== b.propertyOffset) {\n            return a.propertyOffset - b.propertyOffset;\n        }\n        // Sort utilities, components, etc… in the order they were registered\n        return a.index - b.index;\n    }\n    /**\n   * Arbitrary variants are recorded in the order they're encountered.\n   * This means that the order is not stable between environments and sets of content files.\n   *\n   * In order to make the order stable, we need to remap the arbitrary variant offsets to\n   * be in alphabetical order starting from the offset of the first arbitrary variant.\n   */ recalculateVariantOffsets() {\n        // Sort the variants by their name\n        let variants = Array.from(this.variantOffsets.entries()).filter(([v])=>v.startsWith(\"[\")).sort(([a], [z])=>fastCompare(a, z));\n        // Sort the list of offsets\n        // This is not necessarily a discrete range of numbers which is why\n        // we're using sort instead of creating a range from min/max\n        let newOffsets = variants.map(([, offset])=>offset).sort((a, z)=>(0, _bigSign.default)(a - z));\n        // Create a map from the old offsets to the new offsets in the new sort order\n        /** @type {[bigint, bigint][]} */ let mapping = variants.map(([, oldOffset], i)=>[\n                oldOffset,\n                newOffsets[i]\n            ]);\n        // Remove any variants that will not move letting us skip\n        // remapping if everything happens to be in order\n        return mapping.filter(([a, z])=>a !== z);\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ remapArbitraryVariantOffsets(list) {\n        let mapping = this.recalculateVariantOffsets();\n        // No arbitrary variants? Nothing to do.\n        // Everyhing already in order? Nothing to do.\n        if (mapping.length === 0) {\n            return list;\n        }\n        // Remap every variant offset in the list\n        return list.map((item)=>{\n            let [offset, rule] = item;\n            offset = {\n                ...offset,\n                variants: (0, _remapbitfield.remapBitfield)(offset.variants, mapping)\n            };\n            return [\n                offset,\n                rule\n            ];\n        });\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ sortArbitraryProperties(list) {\n        // Collect all known arbitrary properties\n        let known = new Set();\n        for (let [offset] of list){\n            if (offset.arbitrary === 1n) {\n                known.add(offset.property);\n            }\n        }\n        // No arbitrary properties? Nothing to do.\n        if (known.size === 0) {\n            return list;\n        }\n        // Sort the properties alphabetically\n        let properties = Array.from(known).sort();\n        // Create a map from the property name to its offset\n        let offsets = new Map();\n        let offset = 1n;\n        for (let property of properties){\n            offsets.set(property, offset++);\n        }\n        // Apply the sorted offsets to the list\n        return list.map((item)=>{\n            let [offset, rule] = item;\n            var _offsets_get;\n            offset = {\n                ...offset,\n                propertyOffset: (_offsets_get = offsets.get(offset.property)) !== null && _offsets_get !== void 0 ? _offsets_get : 0n\n            };\n            return [\n                offset,\n                rule\n            ];\n        });\n    }\n    /**\n   * @template T\n   * @param {[RuleOffset, T][]} list\n   * @returns {[RuleOffset, T][]}\n   */ sort(list) {\n        // Sort arbitrary variants so they're in alphabetical order\n        list = this.remapArbitraryVariantOffsets(list);\n        // Sort arbitrary properties so they're in alphabetical order\n        list = this.sortArbitraryProperties(list);\n        return list.sort(([a], [b])=>(0, _bigSign.default)(this.compare(a, b)));\n    }\n}\n/**\n *\n * @param {bigint[]} nums\n * @returns {bigint|null}\n */ function max(nums) {\n    let max = null;\n    for (const num of nums){\n        max = max !== null && max !== void 0 ? max : num;\n        max = max > num ? max : num;\n    }\n    return max;\n}\n/**\n * A fast ASCII order string comparison function.\n *\n * Using `.sort()` without a custom compare function is faster\n * But you can only use that if you're sorting an array of\n * only strings. If you're sorting strings inside objects\n * or arrays, you need must use a custom compare function.\n *\n * @param {string} a\n * @param {string} b\n */ function fastCompare(a, b) {\n    let aLen = a.length;\n    let bLen = b.length;\n    let minLen = aLen < bLen ? aLen : bLen;\n    for(let i = 0; i < minLen; i++){\n        let cmp = a.charCodeAt(i) - b.charCodeAt(i);\n        if (cmp !== 0) return cmp;\n    }\n    return aLen - bLen;\n}\n"],"mappings":"AAAA;AACA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EACzCC,KAAK,EAAE;AACX,CAAC,CAAC;AACFH,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,SAAS,EAAE;EACtCE,UAAU,EAAE,IAAI;EAChBC,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,OAAOC,OAAO;EAClB;AACJ,CAAC,CAAC;AACF,MAAMC,QAAQ,GAAG,aAAcC,wBAAwB,CAACC,OAAO,CAAC,iBAAiB,CAAC,CAAC;AACnF,MAAMC,cAAc,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AACrD,SAASD,wBAAwBA,CAACG,GAAG,EAAE;EACnC,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IACjCE,OAAO,EAAEF;EACb,CAAC;AACL;AACA,MAAML,OAAO,CAAC;EACVQ,WAAWA,CAAA,EAAE;IACT;AACR;AACA;AACA;AACA;IAAQ,IAAI,CAACC,OAAO,GAAG;MACXC,QAAQ,EAAE,EAAE;MACZC,IAAI,EAAE,EAAE;MACRC,UAAU,EAAE,EAAE;MACdC,SAAS,EAAE,EAAE;MACbC,QAAQ,EAAE,EAAE;MACZC,IAAI,EAAE;IACV,CAAC;IACD;AACR;AACA;AACA;AACA;IAAQ,IAAI,CAACC,cAAc,GAAG;MAClBN,QAAQ,EAAE,EAAE;MACZC,IAAI,EAAE,EAAE;MACRC,UAAU,EAAE,EAAE;MACdC,SAAS,EAAE,EAAE;MACb;MACA;MACAE,IAAI,EAAE,EAAE;MACRD,QAAQ,EAAE;IACd,CAAC;IACD;AACR;AACA;AACA;AACA;IAAQ,IAAI,CAACG,mBAAmB,GAAG,EAAE;IAC7B;AACR;AACA;AACA;AACA;IAAQ,IAAI,CAACC,cAAc,GAAG,IAAIC,GAAG,EAAE;EACnC;EACA;AACJ;AACA;AACA;EAAMC,MAAMA,CAACC,KAAK,EAAE;IACZ,OAAO;MACHA,KAAK;MACLC,WAAW,EAAED,KAAK;MAClBE,SAAS,EAAE,EAAE;MACbT,QAAQ,EAAE,EAAE;MACZU,aAAa,EAAE,EAAE;MACjBC,KAAK,EAAE,IAAI,CAAChB,OAAO,CAACY,KAAK,CAAC,EAAE;MAC5BK,cAAc,EAAE,EAAE;MAClBC,QAAQ,EAAE,EAAE;MACZC,OAAO,EAAE;IACb,CAAC;EACL;EACA;AACJ;AACA;AACA;EAAMC,iBAAiBA,CAACC,IAAI,EAAE;IACtB,OAAO;MACH,GAAG,IAAI,CAACV,MAAM,CAAC,WAAW,CAAC;MAC3BG,SAAS,EAAE,EAAE;MACbI,QAAQ,EAAEG;IACd,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAAMC,UAAUA,CAACC,OAAO,EAAa;IAAA,IAAXP,KAAK,GAAAQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAC3B,IAAIG,MAAM,GAAG,IAAI,CAAClB,cAAc,CAACnB,GAAG,CAACiC,OAAO,CAAC;IAC7C,IAAII,MAAM,KAAKD,SAAS,EAAE;MACtB,MAAM,IAAIE,KAAK,CAAE,0CAAyCL,OAAQ,EAAC,CAAC;IACxE;IACA,OAAO;MACH,GAAG,IAAI,CAACZ,MAAM,CAAC,UAAU,CAAC;MAC1BN,QAAQ,EAAEsB,MAAM,IAAIE,MAAM,CAACb,KAAK;IACpC,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;EAAMc,kBAAkBA,CAACC,IAAI,EAAER,OAAO,EAAEJ,OAAO,EAAE;IACzCA,OAAO,CAACI,OAAO,GAAGA,OAAO,CAAClB,QAAQ;IAClC,OAAO;MACH,GAAG0B,IAAI;MACPnB,KAAK,EAAE,UAAU;MACjBC,WAAW,EAAEkB,IAAI,CAACnB,KAAK,KAAK,UAAU,GAAGmB,IAAI,CAAClB,WAAW,GAAGkB,IAAI,CAACnB,KAAK;MACtEP,QAAQ,EAAE0B,IAAI,CAAC1B,QAAQ,GAAGkB,OAAO,CAAClB,QAAQ;MAC1Cc,OAAO,EAAEA,OAAO,CAACa,IAAI,GAAG,EAAE,CAACC,MAAM,CAACd,OAAO,EAAEY,IAAI,CAACZ,OAAO,CAAC,GAAGY,IAAI,CAACZ,OAAO;MACvE;MACA;MACA;MACAJ,aAAa,EAAEmB,GAAG,CAAC,CACfH,IAAI,CAAChB,aAAa,EAClBQ,OAAO,CAACR,aAAa,CACxB;IACL,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;EAAMoB,mBAAmBA,CAACR,MAAM,EAAEZ,aAAa,EAAE;IACzC,OAAO;MACH,GAAGY,MAAM;MACTZ,aAAa,EAAEc,MAAM,CAACd,aAAa;IACvC,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAAMqB,cAAcA,CAAC/B,QAAQ,EAAEgC,SAAS,EAAE;IAClC,KAAK,IAAId,OAAO,IAAIlB,QAAQ,EAAC;MACzB,IAAI,CAACiC,aAAa,CAACf,OAAO,EAAEc,SAAS,CAACd,OAAO,CAAC,CAAC;IACnD;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAAMe,aAAaA,CAACf,OAAO,EAAe;IAAA,IAAbgB,OAAO,GAAAf,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAChC,IAAI,CAACf,cAAc,CAAC+B,GAAG,CAACjB,OAAO,EAAE,EAAE,IAAI,IAAI,CAACf,mBAAmB,CAAC;IAChE;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACA,mBAAmB,IAAIqB,MAAM,CAACU,OAAO,CAAC;IAC3C,OAAO;MACH,GAAG,IAAI,CAAC5B,MAAM,CAAC,UAAU,CAAC;MAC1BN,QAAQ,EAAE,IAAI,CAACI,cAAc,CAACnB,GAAG,CAACiC,OAAO;IAC7C,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;EAAMkB,OAAOA,CAACC,CAAC,EAAEC,CAAC,EAAE;IACZ;IACA,IAAID,CAAC,CAAC9B,KAAK,KAAK+B,CAAC,CAAC/B,KAAK,EAAE;MACrB,OAAO,IAAI,CAACL,cAAc,CAACmC,CAAC,CAAC9B,KAAK,CAAC,GAAG,IAAI,CAACL,cAAc,CAACoC,CAAC,CAAC/B,KAAK,CAAC;IACtE;IACA;IACA;IACA,IAAI8B,CAAC,CAAC7B,WAAW,KAAK8B,CAAC,CAAC9B,WAAW,EAAE;MACjC,OAAO,IAAI,CAACN,cAAc,CAACmC,CAAC,CAAC7B,WAAW,CAAC,GAAG,IAAI,CAACN,cAAc,CAACoC,CAAC,CAAC9B,WAAW,CAAC;IAClF;IACA;IACA,KAAK,IAAI+B,QAAQ,IAAIF,CAAC,CAACvB,OAAO,EAAC;MAC3B,KAAK,IAAI0B,QAAQ,IAAIF,CAAC,CAACxB,OAAO,EAAC;QAC3B,IAAIyB,QAAQ,CAACE,EAAE,KAAKD,QAAQ,CAACC,EAAE,EAAE;QACjC,IAAI,CAACF,QAAQ,CAACZ,IAAI,IAAI,CAACa,QAAQ,CAACb,IAAI,EAAE;QACtC,IAAIe,IAAI;QACR,IAAIC,YAAY,GAAG,CAACD,IAAI,GAAGb,GAAG,CAAC,CAC3BU,QAAQ,CAACrB,OAAO,EAChBsB,QAAQ,CAACtB,OAAO,CACnB,CAAC,MAAM,IAAI,IAAIwB,IAAI,KAAK,KAAK,CAAC,GAAGA,IAAI,GAAG,EAAE;QAC3C;QACA,IAAIE,IAAI,GAAG,EAAED,YAAY,GAAGA,YAAY,GAAG,EAAE,CAAC;QAC9C,IAAIE,gBAAgB,GAAGR,CAAC,CAACrC,QAAQ,GAAG4C,IAAI;QACxC,IAAIE,gBAAgB,GAAGR,CAAC,CAACtC,QAAQ,GAAG4C,IAAI;QACxC;QACA,IAAIC,gBAAgB,KAAKC,gBAAgB,EAAE;UACvC;QACJ;QACA,IAAIC,MAAM,GAAGR,QAAQ,CAACZ,IAAI,CAAC;UACvB5C,KAAK,EAAEwD,QAAQ,CAACxD,KAAK;UACrBiE,QAAQ,EAAET,QAAQ,CAACS;QACvB,CAAC,EAAE;UACCjE,KAAK,EAAEyD,QAAQ,CAACzD,KAAK;UACrBiE,QAAQ,EAAER,QAAQ,CAACQ;QACvB,CAAC,CAAC;QACF,IAAID,MAAM,KAAK,CAAC,EAAE,OAAOA,MAAM;MACnC;IACJ;IACA;IACA,IAAIV,CAAC,CAACrC,QAAQ,KAAKsC,CAAC,CAACtC,QAAQ,EAAE;MAC3B,OAAOqC,CAAC,CAACrC,QAAQ,GAAGsC,CAAC,CAACtC,QAAQ;IAClC;IACA;IACA,IAAIqC,CAAC,CAAC3B,aAAa,KAAK4B,CAAC,CAAC5B,aAAa,EAAE;MACrC,OAAO2B,CAAC,CAAC3B,aAAa,GAAG4B,CAAC,CAAC5B,aAAa;IAC5C;IACA;IACA,IAAI2B,CAAC,CAAC5B,SAAS,KAAK6B,CAAC,CAAC7B,SAAS,EAAE;MAC7B,OAAO4B,CAAC,CAAC5B,SAAS,GAAG6B,CAAC,CAAC7B,SAAS;IACpC;IACA;IACA,IAAI4B,CAAC,CAACzB,cAAc,KAAK0B,CAAC,CAAC1B,cAAc,EAAE;MACvC,OAAOyB,CAAC,CAACzB,cAAc,GAAG0B,CAAC,CAAC1B,cAAc;IAC9C;IACA;IACA,OAAOyB,CAAC,CAAC1B,KAAK,GAAG2B,CAAC,CAAC3B,KAAK;EAC5B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAAMsC,yBAAyBA,CAAA,EAAG;IAC1B;IACA,IAAIjD,QAAQ,GAAGkD,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC/C,cAAc,CAACgD,OAAO,EAAE,CAAC,CAACC,MAAM,CAACC,IAAA;MAAA,IAAC,CAACC,CAAC,CAAC,GAAAD,IAAA;MAAA,OAAGC,CAAC,CAACC,UAAU,CAAC,GAAG,CAAC;IAAA,EAAC,CAAC7B,IAAI,CAAC,CAAA8B,KAAA,EAAAC,KAAA;MAAA,IAAC,CAACrB,CAAC,CAAC,GAAAoB,KAAA;MAAA,IAAE,CAACE,CAAC,CAAC,GAAAD,KAAA;MAAA,OAAGE,WAAW,CAACvB,CAAC,EAAEsB,CAAC,CAAC;IAAA,EAAC;IAC7H;IACA;IACA;IACA,IAAIE,UAAU,GAAG7D,QAAQ,CAAC8D,GAAG,CAACC,KAAA;MAAA,IAAC,GAAGzC,MAAM,CAAC,GAAAyC,KAAA;MAAA,OAAGzC,MAAM;IAAA,EAAC,CAACK,IAAI,CAAC,CAACU,CAAC,EAAEsB,CAAC,KAAG,CAAC,CAAC,EAAExE,QAAQ,CAACM,OAAO,EAAE4C,CAAC,GAAGsB,CAAC,CAAC,CAAC;IAC9F;IACA;IAAkC,IAAIK,OAAO,GAAGhE,QAAQ,CAAC8D,GAAG,CAAC,CAAAG,KAAA,EAAgBC,CAAC;MAAA,IAAhB,GAAGC,SAAS,CAAC,GAAAF,KAAA;MAAA,OAAM,CACzEE,SAAS,EACTN,UAAU,CAACK,CAAC,CAAC,CAChB;IAAA,EAAC;IACN;IACA;IACA,OAAOF,OAAO,CAACX,MAAM,CAACe,KAAA;MAAA,IAAC,CAAC/B,CAAC,EAAEsB,CAAC,CAAC,GAAAS,KAAA;MAAA,OAAG/B,CAAC,KAAKsB,CAAC;IAAA,EAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;EAAMU,4BAA4BA,CAACC,IAAI,EAAE;IACjC,IAAIN,OAAO,GAAG,IAAI,CAACf,yBAAyB,EAAE;IAC9C;IACA;IACA,IAAIe,OAAO,CAAC5C,MAAM,KAAK,CAAC,EAAE;MACtB,OAAOkD,IAAI;IACf;IACA;IACA,OAAOA,IAAI,CAACR,GAAG,CAAES,IAAI,IAAG;MACpB,IAAI,CAACjD,MAAM,EAAEI,IAAI,CAAC,GAAG6C,IAAI;MACzBjD,MAAM,GAAG;QACL,GAAGA,MAAM;QACTtB,QAAQ,EAAE,CAAC,CAAC,EAAEV,cAAc,CAACkF,aAAa,EAAElD,MAAM,CAACtB,QAAQ,EAAEgE,OAAO;MACxE,CAAC;MACD,OAAO,CACH1C,MAAM,EACNI,IAAI,CACP;IACL,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EAAM+C,uBAAuBA,CAACH,IAAI,EAAE;IAC5B;IACA,IAAII,KAAK,GAAG,IAAIC,GAAG,EAAE;IACrB,KAAK,IAAI,CAACrD,MAAM,CAAC,IAAIgD,IAAI,EAAC;MACtB,IAAIhD,MAAM,CAACb,SAAS,KAAK,EAAE,EAAE;QACzBiE,KAAK,CAACE,GAAG,CAACtD,MAAM,CAACT,QAAQ,CAAC;MAC9B;IACJ;IACA;IACA,IAAI6D,KAAK,CAACG,IAAI,KAAK,CAAC,EAAE;MAClB,OAAOP,IAAI;IACf;IACA;IACA,IAAIQ,UAAU,GAAG5B,KAAK,CAACC,IAAI,CAACuB,KAAK,CAAC,CAAC/C,IAAI,EAAE;IACzC;IACA,IAAIhC,OAAO,GAAG,IAAIU,GAAG,EAAE;IACvB,IAAIiB,MAAM,GAAG,EAAE;IACf,KAAK,IAAIT,QAAQ,IAAIiE,UAAU,EAAC;MAC5BnF,OAAO,CAACwC,GAAG,CAACtB,QAAQ,EAAES,MAAM,EAAE,CAAC;IACnC;IACA;IACA,OAAOgD,IAAI,CAACR,GAAG,CAAES,IAAI,IAAG;MACpB,IAAI,CAACjD,MAAM,EAAEI,IAAI,CAAC,GAAG6C,IAAI;MACzB,IAAIQ,YAAY;MAChBzD,MAAM,GAAG;QACL,GAAGA,MAAM;QACTV,cAAc,EAAE,CAACmE,YAAY,GAAGpF,OAAO,CAACV,GAAG,CAACqC,MAAM,CAACT,QAAQ,CAAC,MAAM,IAAI,IAAIkE,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAG;MACvH,CAAC;MACD,OAAO,CACHzD,MAAM,EACNI,IAAI,CACP;IACL,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EAAMC,IAAIA,CAAC2C,IAAI,EAAE;IACT;IACAA,IAAI,GAAG,IAAI,CAACD,4BAA4B,CAACC,IAAI,CAAC;IAC9C;IACAA,IAAI,GAAG,IAAI,CAACG,uBAAuB,CAACH,IAAI,CAAC;IACzC,OAAOA,IAAI,CAAC3C,IAAI,CAAC,CAAAqD,KAAA,EAAAC,KAAA;MAAA,IAAC,CAAC5C,CAAC,CAAC,GAAA2C,KAAA;MAAA,IAAE,CAAC1C,CAAC,CAAC,GAAA2C,KAAA;MAAA,OAAG,CAAC,CAAC,EAAE9F,QAAQ,CAACM,OAAO,EAAE,IAAI,CAAC2C,OAAO,CAACC,CAAC,EAAEC,CAAC,CAAC,CAAC;IAAA,EAAC;EAC3E;AACJ;AACA;AACA;AACA;AACA;AACA;AAAI,SAAST,GAAGA,CAACqD,IAAI,EAAE;EACnB,IAAIrD,GAAG,GAAG,IAAI;EACd,KAAK,MAAMsD,GAAG,IAAID,IAAI,EAAC;IACnBrD,GAAG,GAAGA,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAGA,GAAG,GAAGsD,GAAG;IAChDtD,GAAG,GAAGA,GAAG,GAAGsD,GAAG,GAAGtD,GAAG,GAAGsD,GAAG;EAC/B;EACA,OAAOtD,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAAS+B,WAAWA,CAACvB,CAAC,EAAEC,CAAC,EAAE;EAC3B,IAAI8C,IAAI,GAAG/C,CAAC,CAACjB,MAAM;EACnB,IAAIiE,IAAI,GAAG/C,CAAC,CAAClB,MAAM;EACnB,IAAIkE,MAAM,GAAGF,IAAI,GAAGC,IAAI,GAAGD,IAAI,GAAGC,IAAI;EACtC,KAAI,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,MAAM,EAAEpB,CAAC,EAAE,EAAC;IAC3B,IAAIqB,GAAG,GAAGlD,CAAC,CAACmD,UAAU,CAACtB,CAAC,CAAC,GAAG5B,CAAC,CAACkD,UAAU,CAACtB,CAAC,CAAC;IAC3C,IAAIqB,GAAG,KAAK,CAAC,EAAE,OAAOA,GAAG;EAC7B;EACA,OAAOH,IAAI,GAAGC,IAAI;AACtB"},"metadata":{},"sourceType":"script","externalDependencies":[]}